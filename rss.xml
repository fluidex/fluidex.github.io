<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[FluiDex]]></title><description><![CDATA[The website of the FluiDex team.]]></description><link>https://www.fluidex.io</link><generator>GatsbyJS</generator><lastBuildDate>Tue, 19 Oct 2021 02:51:29 GMT</lastBuildDate><item><title><![CDATA[FluiDex]]></title><description><![CDATA[FluiDex FluiDex team is building the first permissionless layer2 orderbook DEX on Ethereum, powered by PLONK zk-rollup. Checkout this…]]></description><link>https://www.fluidex.io/en/index/</link><guid isPermaLink="false">https://www.fluidex.io/en/index/</guid><content:encoded>&lt;h1&gt;FluiDex&lt;/h1&gt;
&lt;p&gt;FluiDex team is building the first permissionless layer2 orderbook DEX on Ethereum, powered by PLONK zk-rollup.&lt;/p&gt;
&lt;p&gt;Checkout &lt;a href=&quot;/en/blog/fluidex-a-zkrollup-layer2-dex/&quot;&gt;this article&lt;/a&gt; for more info.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Contact]]></title><description><![CDATA[Contact Telegram: https://t.me/fluid_dex Medium: https://fluid-dex.medium.com Twitter: https://twitter.com/fluid_dex Email: z@fluidex.io]]></description><link>https://www.fluidex.io/en/contact/</link><guid isPermaLink="false">https://www.fluidex.io/en/contact/</guid><content:encoded>&lt;h2&gt;Contact&lt;/h2&gt;
&lt;p&gt;Telegram: &lt;a href=&quot;https://t.me/fluid_dex&quot;&gt;https://t.me/fluid_dex&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Medium: &lt;a href=&quot;https://fluid-dex.medium.com&quot;&gt;https://fluid-dex.medium.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Twitter: &lt;a href=&quot;https://twitter.com/fluid_dex&quot;&gt;https://twitter.com/fluid_dex&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Email: &lt;a href=&quot;mailto:z@fluidex.io&quot;&gt;z@fluidex.io&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[关于我们]]></title><description><![CDATA[FluiDex 是一个以太坊上的 ZK-Rollup Layer2 去中心化交易所。 技术 FluiDex 使用基于 PLONK 的 ZK-Rollup 技术，在以太坊上实现高性能的去中心化交易，每笔交易的成本会被压缩到传统 Layer1 去中心化交易所的 1/10…]]></description><link>https://www.fluidex.io/zh/about/</link><guid isPermaLink="false">https://www.fluidex.io/zh/about/</guid><content:encoded>&lt;p&gt;&lt;strong&gt;FluiDex 是一个以太坊上的 ZK-Rollup Layer2 去中心化交易所。&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;技术&lt;/h2&gt;
&lt;p&gt;FluiDex 使用基于 PLONK 的 ZK-Rollup 技术，在以太坊上实现高性能的去中心化交易，每笔交易的成本会被压缩到传统 Layer1 去中心化交易所的 &lt;a href=&quot;/zh/blog/zkrollup-intro1/&quot;&gt;1/100 以下&lt;/a&gt;。同时提供等价于 Layer1 的安全性。&lt;/p&gt;
&lt;h2&gt;特性&lt;/h2&gt;
&lt;h3&gt;不妥协的安全性&lt;/h3&gt;
&lt;p&gt;零知识证明技术会保护用户资产的绝对安全。用户无需信任交易所的道德，只需要信任数学和代码。&lt;/p&gt;
&lt;p&gt;交易所作恶可行性为0，无法偷走用户的钱，也无法做恶意的交易。即使在最坏可能性下，交易所意外关停，用户也可以取回自己拥有的资产。&lt;/p&gt;
&lt;h3&gt;无延迟的交易&lt;/h3&gt;
&lt;p&gt;在 Layer1 交易所中，交易需要被打包到块中，才能算作完成[附注1]。 FluiDex 作为 Layer2 交易所，用户的交易订单会被立刻处理，用户能够在一秒之内确认自己的订单状态。&lt;/p&gt;
&lt;h3&gt;低成本&lt;/h3&gt;
&lt;p&gt;用户不需要支付 Layer1 昂贵的 GAS 费即可完成交易。对于资金量小和交易频繁的交易者极为友好。&lt;/p&gt;
&lt;h3&gt;专业的交易服务&lt;/h3&gt;
&lt;p&gt;FluiDex 提供订单簿和 AMM 混合交易模式。普通用户可以使用 AMM 页面或者订单簿页面完成交易，职业交易者可以使用交易 API 完成行情更新和交易委托。专业流动性提供者 (LP)，可以使用 limit / market / post-only / IOC / stoploss order 等丰富的交易种类，并且获得做市商返佣。&lt;/p&gt;
&lt;h3&gt;灵活高效的流动性算法&lt;/h3&gt;
&lt;p&gt;FluiDex 使用 &lt;a href=&quot;/zh/blog/damm/&quot;&gt;自己提出的 Differential AMM 算法&lt;/a&gt;，能够极大地提升资本利用效率和交易盘口深度，并且无缝融合 AMM 与订单簿。此外，FluiDex 也将扮演外部流动性映射角色，能够使用外部 DEX / CEX 增强自身的流动性。&lt;/p&gt;
&lt;h3&gt;无许可上币&lt;/h3&gt;
&lt;p&gt;任何代币发行方能够向 FluiDex 提交自己的代币并增加这个交易币种。此外，代币发行方可以通过设置自己的 AMM 参数，灵活调整交易对的流动性分布，满足普通自动做市 / 单边代币拍卖等多种不同场景需求。&lt;/p&gt;
&lt;!--
## 项目历史

FluiDex 在 2021 年初启动，我们曾写过[打造一个最好的非托管交易所的初心](https://www.fluidex.io/en/blog/fluidex-a-zkrollup-layer2-dex/)。

2021.Q1 FluiDex 开源了 PLONK DSL 工具包 [Plonkit](https://github.com/fluidex/plonkit) 和 Circom 开发工具包 [Snarkit](https://www.fluidex.io/en/blog/the-motivation-of-snarkit/)。

2021.Q2 FluiDex 开源了[后端代码](https://github.com/fluidex/fluidex-backend)，这将是第一个完全开源的 ZK-Rollup DEX 项目。我们希望能够和社区携手努力，共同推动去中心化世界的边界。

## Roadmap

2021.Q4 测试网部署

2022.Q1 主网上线
主网
--&gt;
&lt;h2&gt;创始团队&lt;/h2&gt;
&lt;p&gt;CEO: &lt;a href=&quot;https://www.linkedin.com/in/zhuo-zhang-75340152/&quot;&gt;张卓&lt;/a&gt;。毕业于清华大学计算机系，曾任人工智能独角兽依图科技的语音识别负责人，曾负责 IOST 公链的研发。&lt;/p&gt;
&lt;p&gt;CTO: &lt;a href=&quot;https://www.linkedin.com/in/haoyu-lin-239474123/&quot;&gt;林浩宇&lt;/a&gt;。&lt;a href=&quot;https://vrf-mining.github.io/&quot;&gt;VRF-mining&lt;/a&gt;, &lt;a href=&quot;https://eprint.iacr.org/2020/1033.pdf&quot;&gt;RandChain&lt;/a&gt;, &lt;a href=&quot;https://dl.acm.org/doi/10.1145/3318041.3355460&quot;&gt;fair-atomic-swap&lt;/a&gt; 共同发明人。&lt;a href=&quot;https://zengo.com/research/&quot;&gt;ZenGo-X&lt;/a&gt; 研究员。曾负责比原链研发。&lt;/p&gt;
&lt;h2&gt;联系方式&lt;/h2&gt;
&lt;p&gt;官网：&lt;a href=&quot;https://www.fluidex.io/&quot;&gt;https://www.fluidex.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Telegram 技术群: &lt;a href=&quot;https://t.me/fluid_dex&quot;&gt;https://t.me/fluid_dex&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Medium: &lt;a href=&quot;https://fluid-dex.medium.com&quot;&gt;https://fluid-dex.medium.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Twitter: &lt;a href=&quot;https://twitter.com/fluid_dex&quot;&gt;https://twitter.com/fluid_dex&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;邮箱：&lt;a href=&quot;mailto:contact@fluidex.io&quot;&gt;contact@fluidex.io&lt;/a&gt; 和 &lt;a href=&quot;mailto:z@fluidex.io&quot;&gt;z@fluidex.io&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;公众号: 搜索 “FluiDex”.&lt;/p&gt;
&lt;h2&gt;附注&lt;/h2&gt;
&lt;p&gt;[1]: 暂不考虑链重组。因为这个因素对于 Layer1 Layer2 相同。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[About FluiDex]]></title><description><![CDATA[FluiDex is a ZK-Rollup Layer2 DEX on Ethereum. Technology FluiDex aims at using PLONK-based ZK-Rollup to build a high-performance DEX on…]]></description><link>https://www.fluidex.io/en/about/</link><guid isPermaLink="false">https://www.fluidex.io/en/about/</guid><content:encoded>&lt;p&gt;&lt;strong&gt;FluiDex is a ZK-Rollup Layer2 DEX on Ethereum.&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;Technology&lt;/h2&gt;
&lt;p&gt;FluiDex aims at using PLONK-based ZK-Rollup to build a high-performance DEX on Ethereum. It &lt;a href=&quot;/en/blog/zkrollup-intro1/&quot;&gt;can save the cost of each transaction to 1/100&lt;/a&gt; while still offering the same security level as layer 1.&lt;/p&gt;
&lt;h2&gt;Features&lt;/h2&gt;
&lt;h3&gt;Uncompromising security&lt;/h3&gt;
&lt;p&gt;FluiDex uses Zero-knowledge Proof schemes so that users don’t need to trust the exchange being ethical, the Math/Cryptography behind it can guarantee that users’ funds always stay “SAFU”. The exchange has no way to steal users’ funds or creat unauthorized orders. Even in the worst case that the exchange shuts down, users can still withdraw their funds safely.&lt;/p&gt;
&lt;h3&gt;Trading without latency&lt;/h3&gt;
&lt;p&gt;In a DEX on layer 1, users need to interact with smart contracts and a trade is viewed valid only after it’s included in a block and submitted on chain. However, FluiDex offers a CEX-ish trading experince and can process users’ orders immediately. Users don’t need to wait to know whether a trade succeed or not.&lt;/p&gt;
&lt;h3&gt;Lower costs&lt;/h3&gt;
&lt;p&gt;ZK-Rollup compresses transaction data so as to have lower average gas fee. User don’t need to pay high transaction fee as on layer 1, which is quite friendly to retail users and frequent traders.&lt;/p&gt;
&lt;h3&gt;Professional trading experience&lt;/h3&gt;
&lt;p&gt;FluiDex is a orderbook AMM-hybrid DEX. A retail user may choose to trade through orderbook webpage or AMM webpage. A quant trader / market maker / Liquidity Provider (LP) may choose to monitor the tickers and place/cancel orders via APIs. FluiDex provides professional trading experience, for example it supports limit / market / post-only / IOC / stoploss… order types, and market maker can gain rebates.&lt;/p&gt;
&lt;h3&gt;Flexible and efficient AMM algorithm&lt;/h3&gt;
&lt;p&gt;FluiDex uses the &lt;a href=&quot;/en/blog/damm/&quot;&gt;Differential AMM&lt;/a&gt; we propose, which can noticeably increase the capital efficiency and optimize orderbook depth, can can support both orderbook and AMM seamlessly. FluiDex team itself can also brigde external liquidity from other DEXs/CEXs, to offer better liquidity.&lt;/p&gt;
&lt;h3&gt;Permissionless listing&lt;/h3&gt;
&lt;p&gt;Anyone can list a ERC20 token on FluiDex permissionlessly. And a project team can adjust liquidity distribution by AMM parameters, for
automated market making (AMM) or initial DEX offering (IDO).&lt;/p&gt;
&lt;h2&gt;Co-founders&lt;/h2&gt;
&lt;p&gt;CEO: &lt;a href=&quot;https://www.linkedin.com/in/zhuo-zhang-75340152/&quot;&gt;Zhuo ZHANG&lt;/a&gt;. CS, THU. Previously Speech Recognition Team Lead in &lt;a href=&quot;https://www.yitutech.com/&quot;&gt;YITUTech&lt;/a&gt;, and Tech Lead in &lt;a href=&quot;https://iost.io/&quot;&gt;IOST&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;CTO: &lt;a href=&quot;https://www.linkedin.com/in/haoyu-lin-239474123/&quot;&gt;Haoyu LIN&lt;/a&gt;. Co-author oc &lt;a href=&quot;https://vrf-mining.github.io/&quot;&gt;VRF-mining&lt;/a&gt;, &lt;a href=&quot;https://eprint.iacr.org/2020/1033.pdf&quot;&gt;RandChain&lt;/a&gt; and &lt;a href=&quot;https://dl.acm.org/doi/10.1145/3318041.3355460&quot;&gt;fair-atomic-swap&lt;/a&gt;. Researcher in &lt;a href=&quot;https://zengo.com/research/&quot;&gt;ZenGo-X&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Contact&lt;/h2&gt;
&lt;p&gt;Website: &lt;a href=&quot;https://www.fluidex.io/&quot;&gt;https://www.fluidex.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Telegram: &lt;a href=&quot;https://t.me/fluid_dex&quot;&gt;https://t.me/fluid_dex&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Medium: &lt;a href=&quot;https://fluid-dex.medium.com&quot;&gt;https://fluid-dex.medium.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Twitter: &lt;a href=&quot;https://twitter.com/fluid_dex&quot;&gt;https://twitter.com/fluid_dex&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Email: &lt;a href=&quot;mailto:contact@fluidex.io&quot;&gt;contact@fluidex.io&lt;/a&gt; or &lt;a href=&quot;mailto:z@fluidex.io&quot;&gt;z@fluidex.io&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;Wechat Official Account: “FluiDex”&lt;/p&gt;
&lt;h2&gt;Footnote&lt;/h2&gt;
&lt;p&gt;[1]: We would like to save the effort of discussing chain re-organizations for now. Becaue that’s what layer 1 should consider and handle.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[联系我们]]></title><description><![CDATA[联系我们 Telegram: https://t.me/fluid_dex Medium: https://fluid-dex.medium.com Twitter: https://twitter.com/fluid_dex Email: z@fluidex.io]]></description><link>https://www.fluidex.io/zh/contact/</link><guid isPermaLink="false">https://www.fluidex.io/zh/contact/</guid><content:encoded>&lt;h2&gt;联系我们&lt;/h2&gt;
&lt;p&gt;Telegram: &lt;a href=&quot;https://t.me/fluid_dex&quot;&gt;https://t.me/fluid_dex&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Medium: &lt;a href=&quot;https://fluid-dex.medium.com&quot;&gt;https://fluid-dex.medium.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Twitter: &lt;a href=&quot;https://twitter.com/fluid_dex&quot;&gt;https://twitter.com/fluid_dex&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Email: &lt;a href=&quot;mailto:z@fluidex.io&quot;&gt;z@fluidex.io&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[FluiDex]]></title><description><![CDATA[FluiDex FluiDex Labs 致力于构建下一代专业的去中心化交易所。我们将在以太坊上使用 PLONK 零知识证明技术，开发高性能的订单簿数字资产现货交易所。完整的项目介绍见这里。]]></description><link>https://www.fluidex.io/zh/index/</link><guid isPermaLink="false">https://www.fluidex.io/zh/index/</guid><content:encoded>&lt;h1&gt;FluiDex&lt;/h1&gt;
&lt;p&gt;FluiDex Labs 致力于构建下一代专业的去中心化交易所。我们将在以太坊上使用 PLONK 零知识证明技术，开发高性能的订单簿数字资产现货交易所。完整的项目介绍见&lt;a href=&quot;/zh/blog/fluidex-a-zkrollup-layer2-dex/&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Introducing plonkit]]></title><description><![CDATA[We are proudly to annouce that, FluiDex has received an ESP grant from Ethereum Foundation for our plonkit.
And since this work now gets…]]></description><link>https://www.fluidex.io/en/blog/introducing-plonkit/</link><guid isPermaLink="false">https://www.fluidex.io/en/blog/introducing-plonkit/</guid><pubDate>Tue, 19 Oct 2021 20:00:00 GMT</pubDate><content:encoded>&lt;p&gt;We are proudly to annouce that, FluiDex has received an &lt;a href=&quot;https://esp.ethereum.foundation/&quot;&gt;ESP grant&lt;/a&gt; from Ethereum Foundation for our &lt;a href=&quot;https://github.com/fluidex/plonkit&quot;&gt;plonkit&lt;/a&gt;.
And since this work now gets completed, we would like to share more information about it.&lt;/p&gt;
&lt;h2&gt;TL;DR&lt;/h2&gt;
&lt;p&gt;Plonkit is a zkSNARK toolkit to work with &lt;a href=&quot;https://github.com/iden3/circom&quot;&gt;Circom&lt;/a&gt;, a developer-friendly ZKP circuit language, in &lt;a href=&quot;https://eprint.iacr.org/2019/953.pdf&quot;&gt;PLONK proof system&lt;/a&gt;. It allows generating proof, verifying and exporting verifier smart contract.&lt;/p&gt;
&lt;h2&gt;The motivation of plonkit&lt;/h2&gt;
&lt;p&gt;To date, &lt;a href=&quot;https://eprint.iacr.org/2019/953.pdf&quot;&gt;PLONK&lt;/a&gt; is one of the most performant zk-SNARKS proof systems in terms of proving time and proof size. &lt;a href=&quot;https://vitalik.ca/general/2019/09/22/plonk.html&quot;&gt;As explained by Vitalik Buterin&lt;/a&gt;, by being benefited from “universal and updateable” setup, PLONK is more secure when compared to &lt;a href=&quot;https://eprint.iacr.org/2016/260.pdf&quot;&gt;Groth16&lt;/a&gt;, without introducing much performance loss.&lt;/p&gt;
&lt;p&gt;However, it is inefficient to write circuits in pure C++/Rust/… , which requires writing a lot of constraints by hand. By using developer-friendly Circom DSL, people can then write circuits more efficiently and more conveniently. Aiming at bringing PLONK to Circom ecosystem, plonkit is designed. &lt;sup id=&quot;fnref-1&quot;&gt;&lt;a href=&quot;#fn-1&quot; class=&quot;footnote-ref&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;h2&gt;Functionalities&lt;/h2&gt;
&lt;p&gt;The functionalities of plonkit include:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Local Structured-Reference-String (SRS) setup&lt;/li&gt;
&lt;li&gt;Verification Key Generation (corresponding to a given circuit)&lt;/li&gt;
&lt;li&gt;Proof Generation&lt;/li&gt;
&lt;li&gt;Proof Verfication&lt;/li&gt;
&lt;li&gt;Verifier Smart Contract Generation&lt;/li&gt;
&lt;li&gt;Proof Aggregation&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Local SRS setup&lt;/h3&gt;
&lt;p&gt;To export a verification key and to generate a proof (both explained later), we need a Structured-Reference-String. In &lt;a href=&quot;https://github.com/fluidex/plonkit/blob/master/test/test_poseidon_plonk.sh&quot;&gt;test_poseidon_plonk.sh&lt;/a&gt;, we provide a download link &lt;sup id=&quot;fnref-2&quot;&gt;&lt;a href=&quot;#fn-2&quot; class=&quot;footnote-ref&quot;&gt;2&lt;/a&gt;&lt;/sup&gt; for a SRS file previously set up. According to &lt;a href=&quot;https://github.com/matter-labs/bellman/blob/f551a55d83d2ea604b2dbfe096fd9dcfdaedb189/src/kate_commitment/mod.rs#L1090&quot;&gt;matter-labs&lt;/a&gt;, this SRS file is parsed from &lt;a href=&quot;https://medium.com/aztec-protocol/aztec-announcing-our-ignition-ceremony-757850264cfe&quot;&gt;AZTEC’s ignition setup&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;For the convenience for testing, we add the support for genenrating SRS locally.&lt;/p&gt;
&lt;h3&gt;Verification Key Generation&lt;/h3&gt;
&lt;p&gt;Users can export a verification key for a circuit. The verification key is needed for future proof verification.&lt;/p&gt;
&lt;h3&gt;Proof Generation&lt;/h3&gt;
&lt;p&gt;A prover can generate a proof proving he knows a witness satisfying the circuit.&lt;/p&gt;
&lt;h3&gt;Proof Verfication&lt;/h3&gt;
&lt;p&gt;Proof verfication is to verified a proof using a verification key.&lt;/p&gt;
&lt;h3&gt;Verifier Smart Contract Generation&lt;/h3&gt;
&lt;p&gt;Users can generate a verifier smart contract based on a verification key, then a proof can be verified on EVM using this smart contract.&lt;/p&gt;
&lt;h3&gt;Proof Aggregation&lt;/h3&gt;
&lt;p&gt;Plonkit wraps up &lt;a href=&quot;https://github.com/matter-labs/recursive_aggregation_circuit&quot;&gt;recursive_aggregation_circuit&lt;/a&gt; to achieve proof aggregation. Proof aggregation is based on “Recursive Proof Composition” described in &lt;a href=&quot;https://eprint.iacr.org/2019/1021.pdf&quot;&gt;Halo&lt;/a&gt; paper.&lt;/p&gt;
&lt;p&gt;Some points worth noting (in the following explanations “we” stands for both “plonkit” and &lt;a href=&quot;https://github.com/matter-labs/recursive_aggregation_circuit&quot;&gt;recursive_aggregation_circuit&lt;/a&gt;):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Unlike Halo, we don’t use cyclic curves but simulate base field operations &lt;sup id=&quot;fnref-3&quot;&gt;&lt;a href=&quot;#fn-3&quot; class=&quot;footnote-ref&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;, because on Ethereum we only have one curve (BN_254).&lt;/li&gt;
&lt;li&gt;We aggregate multiple proof into an aggregated proof in one step, instead of iterating and aggregating one by one.&lt;/li&gt;
&lt;li&gt;We don’t check the pairing in the circuit. Instead, we aggregate the pairing points and check the pairing in smart contract.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Workflow / Usecase&lt;/h2&gt;
&lt;p&gt;The diagram below demonstrates a typical workflow of using plonkit:&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/b83f1e0a8f618a8a753621d467492acf/7dd84/plonkit.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 39.87341772151899%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAD2EAAA9hAHVrK90AAACJUlEQVQoz01Sy4vSURQ+YxOIJOM0/YaKZtmQEtYsmiCFNmMRjS36AyqCGRI3Lgx0MTtBEREZxRciKKKiIj5ARcXH+AbxzagguFJCyUVtJIhf5wpFFy6H853Xd757IR6PM1KpFCMYDG7RNA25XA7W6zWYzWbIZrOMYrHIGA6H24vFArrdrq3dbtO9Xm8tkUgeVyqV15jzCgCYFEXtADnYENLpNEQiEUgkEhvs8vISHA4HYDOoVqtgsVhguVxCrVZ7gXkXmH+uVCo5Ho+H43a7d7HkJofDoQghCIVCR7FY7LnX6933+/1AQJ1OB1ar9RYOeJbJZI5dLteuQqGAcDi8iZMrFothPB5DIBAAjBMeTJPJBHB9ff0TA3Sz2bxA8IZUKmWjZTidzvfz+ZzGVWlcS0KaFAqF2yqV6kitVj8kvlAoBC6XC1qt9o5cLn9qMBjuEZ1OSqXSKep4QKgzmcxDtKxGo8HO5/NvUKe3yPQ+Yux6ve6czWb0dDr9hqu+7Pf7n1ksFoXaxlerFY3xHzAajb5jAl0ulxVYtC0QCPZJY9TwHTL/NZlMfuOwM8Iah/N9Pt8n1PHUaDTuIE6RGpTsGLEPyWTyBFqt1sfBYPAFhX7yVx9ybTbbQafTOUMW55h8SDCNRvMvLpPJADcDHo8HdrudaLiF7wGARURHsjr83xAZkG8COAyi0ShcXV1tfgCfz99DQ+n1+kcoy1eRSHQX/b0HeEjdH+dbR5RZJ2+cAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;plonkit&quot;
        title=&quot;plonkit&quot;
        src=&quot;/static/b83f1e0a8f618a8a753621d467492acf/f058b/plonkit.png&quot;
        srcset=&quot;/static/b83f1e0a8f618a8a753621d467492acf/c26ae/plonkit.png 158w,
/static/b83f1e0a8f618a8a753621d467492acf/6bdcf/plonkit.png 315w,
/static/b83f1e0a8f618a8a753621d467492acf/f058b/plonkit.png 630w,
/static/b83f1e0a8f618a8a753621d467492acf/40601/plonkit.png 945w,
/static/b83f1e0a8f618a8a753621d467492acf/78612/plonkit.png 1260w,
/static/b83f1e0a8f618a8a753621d467492acf/7dd84/plonkit.png 3732w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;The &lt;a href=&quot;https://github.com/fluidex/plonkit/blob/master/test/test_poseidon_plonk.sh&quot;&gt;test_poseidon_plonk.sh&lt;/a&gt; script is also a comprehensive example of the whole workflow.&lt;/p&gt;
&lt;h2&gt;Acknowledgements&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Plonkit builds on top of the awesome libraries written by matter-labs:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/matter-labs/bellman&quot;&gt;bellman_ce&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/matter-labs/solidity_plonk_verifier&quot;&gt;solidity_plonk_verifier&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/matter-labs/recursive_aggregation_circuit&quot;&gt;recursive_aggregation_circuit&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Plonkit also borrows some “R1CSFile reader” codes from &lt;a href=&quot;https://github.com/poma/zkutil&quot;&gt;zkUtil&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;What is more, without the great effort of &lt;a href=&quot;https://github.com/iden3/circom&quot;&gt;Circom&lt;/a&gt;, plonkit won’t have the opportunity to bring a friendly ZKP circuit development experience to developers.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Thanks the great work of these teams/individuals!&lt;/p&gt;
&lt;p&gt;Try out plonkit &lt;a href=&quot;https://github.com/fluidex/plonkit&quot;&gt;here&lt;/a&gt; and have fun!&lt;/p&gt;
&lt;div class=&quot;footnotes&quot;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&quot;fn-1&quot;&gt;
&lt;p&gt;By the time of starting plonkit project, Circom/snarkJS didn’t support PLONK but &lt;a href=&quot;https://blog.iden3.io/circom-snarkjs-plonk.html&quot;&gt;it does now&lt;/a&gt;. Still, proving in plonkit is more efficient than in snarkJS (plonkit uses Rust and snarkJS uses JS, and their PLONK implementations are different), whereas snarkJS can be run in browsers but plonkit cannot.&lt;/p&gt;
&lt;a href=&quot;#fnref-1&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;
&lt;/li&gt;
&lt;li id=&quot;fn-2&quot;&gt;
&lt;p&gt;Taken from &lt;a href=&quot;https://github.com/matter-labs/zksync/blob/master/infrastructure/zk/src/run/run.ts#L77&quot;&gt;https://github.com/matter-labs/zksync/blob/master/infrastructure/zk/src/run/run.ts#L77&lt;/a&gt;&lt;/p&gt;
&lt;a href=&quot;#fnref-2&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;
&lt;/li&gt;
&lt;li id=&quot;fn-3&quot;&gt;
&lt;p&gt;We simulate base field elements as “limb”s.&lt;/p&gt;
&lt;a href=&quot;#fnref-3&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content:encoded></item><item><title><![CDATA[打磨第一个完全开源的 ZK-Rollup DEX: FluiDex 架构介绍]]></title><description><![CDATA[摘要：本文将介绍 FluiDex 团队开源的 ZK-Rollup DEX 后端的架构设计。 The cryptography underlying zero knowledge proofs has undergone a Moore’s Law-like trajectory…]]></description><link>https://www.fluidex.io/zh/blog/fluidex-architecture/</link><guid isPermaLink="false">https://www.fluidex.io/zh/blog/fluidex-architecture/</guid><pubDate>Wed, 14 Jul 2021 20:00:00 GMT</pubDate><content:encoded>&lt;p&gt;摘要：本文将介绍 FluiDex 团队开源的 ZK-Rollup DEX 后端的架构设计。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The cryptography underlying zero knowledge proofs has undergone a Moore’s Law-like trajectory over the last few years, and it shows no sign of slowing down.&lt;/p&gt;
&lt;p&gt;— &lt;a href=&quot;https://medium.com/dragonfly-research/im-worried-nobody-will-care-about-rollups-554bc743d4f1&quot;&gt;Dragonfly Research&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;ZK-Rollup 以其出色的去中心化和安全性优势，被包括 Ethereum 创始人 Vitalik 在内的很多人认为是长期最重要的 Layer 2 扩容方案。但另一方面，技术优势的反面恰恰是高门槛，无论是技术基础设施，还是用户可见的产品，相关项目实际上都屈指可数。&lt;a href=&quot;https://github.com/fluidex&quot;&gt;FluiDex&lt;/a&gt; 作为全世界少数几个在独立开发完整 ZK-Rollup 系统的团队，希望能够持续分享一些自己的经验和成果，和业界一起共同推动 ZK-Rollup 生态边界的不断扩张。&lt;/p&gt;
&lt;p&gt;我们曾在 &lt;a href=&quot;/zh/blog/zkrollup-intro1/&quot;&gt;ZK-Rollup 开发经验分享 Part I&lt;/a&gt; 中对 ZK-Rollup 做了一个概括的介绍，读者可以先从这篇文章获得更多的背景知识。作为“开发经验分享”系列文章的第二篇，本文将会介绍我们团队 &lt;a href=&quot;https://github.com/fluidex/fluidex-backend&quot;&gt;近期开源的 ZK-Rollup DEX 后端&lt;/a&gt; 的整体架构，希望帮到更多的开发者，能够为 ZK-Rollup 的大规模应用出一份力。&lt;/p&gt;
&lt;h2&gt;整体架构&lt;/h2&gt;
&lt;p&gt;下图是 FluiDex 后端的整体架构图。概括地说，用户把交易请求（包括订单委托和 AMM 请求）发送到撮合引擎，撮合引擎将所有完成的交易发送到消息队列，Rollup 模块将消息队列中的交易在 Merkle tree 上更新，打包成 L2 blocks。之后  l2 blocks  由 prover cluster 生成证明，就可以最终被发布在链上。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;
  &lt;img src=&quot;/08029b15199d30179156deadc002f90b/FluiDex Architecture.svg&quot; width=&quot;600&quot;&gt;
&lt;/p&gt;
&lt;p&gt;我们将先分模块地介绍每个服务模块的作用，最后介绍 ZK-Rollup 系统设计的一般原则。&lt;/p&gt;
&lt;h2&gt;各服务介绍&lt;/h2&gt;
&lt;h3&gt;Gateway&lt;/h3&gt;
&lt;p&gt;Gateway 接受从 网页端 / 移动端 / 客户交易机器人发送来的交易请求，路由之后发送到不同的具体服务。Gateway 也会将内部的行情和委托状态更新，变成适配于请求方的格式推送给请求方&lt;sup id=&quot;fnref-1&quot;&gt;&lt;a href=&quot;#fn-1&quot; class=&quot;footnote-ref&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;。 考虑到 Envoy 在性能/动态配置等方面都有良好表现，我们使用 Envoy 作为系统的网关组件。此外，FluiDex 内部大量使用 GRPC 来完成单向的 RPC 和 双向的 streaming，Envoy 对 GRPC 也有出色的支持。&lt;/p&gt;
&lt;h3&gt;撮合引擎&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/fluidex/dingir-exchange&quot;&gt;dingir exchange&lt;/a&gt; 是一个高性能交易所撮合引擎。它在内存中完成用户订单的撮合。我们使用 BTreeMap&lt;sup id=&quot;fnref-2&quot;&gt;&lt;a href=&quot;#fn-2&quot; class=&quot;footnote-ref&quot;&gt;2&lt;/a&gt;&lt;/sup&gt; 来实现 Orderbook，因为撮合引擎订单簿既需要 key-value 查询（查询订单信息），也需要有序遍历（撮合），这要求一种类似 AVL tree / skip list 这类有序关联数组，我们考虑到现代 CPU 的缓存特性，使用了对缓存更友好的 BTreeMap。&lt;/p&gt;
&lt;p&gt;服务状态的持久化通过定期 dump 和 operation log 实现。服务通过定期的 fork 后，新进程会进行全局状态的持久化。比起 stop-world and deep-copy 的方式，fork 提供了更好的请求延迟指标。此外，所有的写请求作为 operation logs 被&lt;strong&gt;批量地&lt;/strong&gt;（否则会给数据库造成很大的压力）追加写入数据库中。全局状态定期持久化 + operation log 两种持久化方式结合在一起，即使在最坏的宕机情况下，也仅仅需要回滚几秒的交易。&lt;/p&gt;
&lt;p&gt;行情的计算通过 TimescaleDB 时序数据库完成。完成的交易在 TimescaleDB 中被按照预定的时间间隔按照 bucket 统计，生成 K 线指标。&lt;/p&gt;
&lt;h3&gt;Rollup State Manager&lt;/h3&gt;
&lt;p&gt;ZK Rollup 系统中，链上合约只需要储存全局状态的 Merkle root，而不需要记录完整的系统状态信息。维护 Merkle tree 的工作由链下的 rollup state manager 完成。rollup state manager 从消息队列接收每个完成的交易，在 Merkle tree 上更新。并且对于多个交易，批量的生成 L2 block。&lt;/p&gt;
&lt;p&gt;Rollup 定时 dump 出 checkpoint，checkpoint 中会包含消息队列的 offset。服务重启时，加载上一次  checkpoint 的 Merkle tree 状态，并且 seek 到上次状态对应的消息队列 offset，之后重新处理消息队列中的交易。&lt;/p&gt;
&lt;h3&gt;Prover Cluster&lt;/h3&gt;
&lt;p&gt;L2 blocks 被 rollup state manager 生成后，上链被合约验证时还需要一份对应的密码学证明。这需要一个证明集群来提供大量算力。此外，由于 DEX 业务不同时段的交易量可能变化很大，因此这个证明集群必须是高拓展性和高弹性的。&lt;/p&gt;
&lt;p&gt;我们采用了 Master-Worker 架构。一个有状态的 master 节点管理证明任务的元信息，众多无状态的 worker 节点从 master 获取任务，证明完成后向 master 提交。和 PoW 挖矿相似， 长远来看，由于 ZK-Rollup 验证的计算量远远小于证明的计算量，这使得我们未来能够转换到一种更加“无信任”的架构，即外部的无需可节点（矿工）可以自由的加入和退出证明集群，验证节点能够快速确认矿工诚实地完成了计算，没有作恶。&lt;/p&gt;
&lt;p&gt;目前 prover cluster 提供单机 Docker Compose 和 K8S 两种不同部署方式，能够同时支持本地开发调试和正式生产部署。&lt;/p&gt;
&lt;h2&gt;通用架构设计原则&lt;/h2&gt;
&lt;h3&gt;CQRS &amp;#x26; 全局消息总线&lt;/h3&gt;
&lt;p&gt;Rollup 系统的状态更新需要确保强一致性，不能允许分毫的误差。所有的状态更新操作，最好是可追溯可重放的。我们采用了 &lt;a href=&quot;https://docs.microsoft.com/en-us/azure/architecture/patterns/cqrs&quot;&gt;CQRS&lt;/a&gt; 设计模式来提供这种可靠的状态更新。&lt;strong&gt;所有对于全局状态的写操作，都由 Message Queue 完成同步。&lt;/strong&gt; 具体地，我们使用 Kafka 作为全局消息总线。Rollup 系统以 message queue 作为 ground truth，从 message queue 中获得每一个表示状态更新的消息，将其在全局的 Merkle tree 上执行。&lt;/p&gt;
&lt;h3&gt;以内存为中心的数据组织&lt;/h3&gt;
&lt;p&gt;一般的互联网服务以数据库作为数据的 ground truth。通过数据的分片和服务的无状态性来实现整体系统的拓展性和伸缩性。 &lt;/p&gt;
&lt;p&gt;与此相反，在我们 ZK-Rollup 系统中，很多服务都需要在内存中维护大量复杂的数据结构（如 Rollup 和 matching engine 服务，分别维护 Merkle tree 和 orderbook）。这要求一种以内存数据为中心的架构设计。这导致我们很多的设计原则可能和互联网业务推崇的 &lt;a href=&quot;https://12factor.net/&quot;&gt;12 Factor&lt;/a&gt; 不一致，反而更接近于游戏服务端。&lt;/p&gt;
&lt;h3&gt;单一的技术栈&lt;/h3&gt;
&lt;p&gt;由于 Rust 语言在类型安全和所有权检查的优异特性，以及不输于 C++ 的性能，Rust 成为了不少密码学库的首选，生态也日益繁荣。我们的 rollup state manager 和 prover cluster 很自然地使用了 Rust 语言开发。此外，考虑到统一的技术栈无论从技术还是团队管理角度都能极大减小摩擦， 系统中的其他服务模块目前也都是用 Rust 语言实现。&lt;/p&gt;
&lt;h2&gt;代码 &amp;#x26; 运行&lt;/h2&gt;
&lt;p&gt;目前 FluiDex-backend 已经 &lt;a href=&quot;https://github.com/fluidex/fluidex-backend&quot;&gt;开源到 Github&lt;/a&gt;。目前仅支持本机启动。具体的代码说明和运行方式见 Github 代码库页面 。&lt;/p&gt;
&lt;div class=&quot;footnotes&quot;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&quot;fn-1&quot;&gt;
&lt;p&gt;grpc-&gt;websocket, 目前尚未实现&lt;/p&gt;
&lt;a href=&quot;#fnref-1&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;
&lt;/li&gt;
&lt;li id=&quot;fn-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/std/collections/struct.BTreeMap.html&quot;&gt;https://doc.rust-lang.org/stable/std/collections/struct.BTreeMap.html&lt;/a&gt;&lt;/p&gt;
&lt;a href=&quot;#fnref-2&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content:encoded></item><item><title><![CDATA[A Dive into FluiDex's Architecture]]></title><description><![CDATA[The cryptography underlying zero knowledge proofs has undergone a Moore’s Law-like trajectory over the last few years, and it shows no sign…]]></description><link>https://www.fluidex.io/en/blog/fluidex-architecture/</link><guid isPermaLink="false">https://www.fluidex.io/en/blog/fluidex-architecture/</guid><pubDate>Wed, 14 Jul 2021 20:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;The cryptography underlying zero knowledge proofs has undergone a Moore’s Law-like trajectory over the last few years, and it shows no sign of slowing down.&lt;/p&gt;
&lt;p&gt;— &lt;a href=&quot;https://medium.com/dragonfly-research/im-worried-nobody-will-care-about-rollups-554bc743d4f1&quot;&gt;Dragonfly Research&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;ZK-Rollup, with its terrific security and decentralization properties, is believed as the most important Layer 2 scaling solution in the long term. However, the nice features of ZK-Rollup come with a cost of technical difficulties, in terms of both cryptography and engineering. No wonder why there are only a few relevant devtools or user-end products out there. As one of the a few teams that are developing a ZK-Rollup system from scratch instead of forking, &lt;a href=&quot;https://github.com/fluidex&quot;&gt;FluiDex&lt;/a&gt; decides to share some of our experience and outcomes with the industry, to help explode the ZK-Rollup ecosystem.&lt;/p&gt;
&lt;p&gt;Before moving on, we recommend our readers to check out the article &lt;a href=&quot;/en/blog/zkrollup-intro1/&quot;&gt;“ZK-Rollup development experience sharing, Part I”&lt;/a&gt;, in which we talk about how to develop and optimize a ZK-Rollup. As the second part of this “development experience-sharing” series, this article focuses on our &lt;a href=&quot;https://github.com/fluidex/fluidex-backend&quot;&gt;recently open-sourced back-end architecture&lt;/a&gt;, aiming at guiding more developers into the ZK-Rollup ecosystem.&lt;/p&gt;
&lt;h2&gt;Overall Architecture&lt;/h2&gt;
&lt;p&gt;The diagram below shows the overall architecture of FluiDex’s back-end. In a nutshell, users send order requests to the matching engine, and the matching engine sends all the finished orders to the message queue. The rollup module then updates the states (users’ orders, users’ balances…) on the Merkle tree and packs the messages (after some format conversions) into L2 blocks. After L2 blocks being proved by our prover cluster, they will be published onto chain.&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;
  &lt;img src=&quot;/08029b15199d30179156deadc002f90b/FluiDex Architecture.svg&quot; width=&quot;600&quot;&gt;
&lt;/p&gt;
&lt;p&gt;We will now first introduce the functionalities and responsibilities of each submodule, and then summarize the design principles of our system.&lt;/p&gt;
&lt;h2&gt;Submodules&lt;/h2&gt;
&lt;h3&gt;Gateway&lt;/h3&gt;
&lt;p&gt;Gateway is to accept order requests from front-end or quant trading bots, and to route them into different micro-services. Gateway will also push the up-to-date internal market k-line and orderbook information to the ticker subscribers&lt;sup id=&quot;fnref-1&quot;&gt;&lt;a href=&quot;#fn-1&quot; class=&quot;footnote-ref&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; in a desired format. Given the excellent performance and configuration flexibility, we choose Envoy for our gateway. Besides, note that FluiDex uses GRPC extensively including both unary RPC and bidirectional streaming RPC, Envoy’s excellent support for GRPC can fulfill our requirements.&lt;/p&gt;
&lt;h3&gt;Matching Engine&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/fluidex/dingir-exchange&quot;&gt;dingir exchange&lt;/a&gt; is a high-performance exchange matching engine. It stores and matches user orders in RAM in real time. We use BTreeMap&lt;sup id=&quot;fnref-2&quot;&gt;&lt;a href=&quot;#fn-2&quot; class=&quot;footnote-ref&quot;&gt;2&lt;/a&gt;&lt;/sup&gt; for our orderbook, because it requires both key-value query (for order details) and in-order traversal (for order matching), which means that it needs an ordered associative array like AVL tree / skip list. Moreover, BTreeMap can benefit from modern CPUs’ cache architecture.&lt;/p&gt;
&lt;p&gt;The persistence of the global state is achieved by periodical dumps and operation logs. By periodical &lt;a href=&quot;https://en.wikipedia.org/wiki/Fork_(system_call)&quot;&gt;process forks&lt;/a&gt;, which has lower latency than “stop-world” and than “deep-copy”, the new child process persists the global state. In addition, all user requests are persisted into the database in batches (otherwise leading to heavy database pressure) as operation logs. The combination of the two persistence mechanisms ensures that if the system suddenly goes down, the system state can be quickly recovered.&lt;/p&gt;
&lt;p&gt;High, low, open, close and volume are queried from TimescaleDB, a time series database, to generate K-line.&lt;/p&gt;
&lt;h3&gt;Rollup State Manager&lt;/h3&gt;
&lt;p&gt;In a ZK-Rollup system, the smart contract only needs to store the Merkle root of the global state instead of the entire Merkle tree of all the states. The maintenance of the Merkle tree is done by the off-chain rollup state manager. Rollup state manager receives finished orders and other operations (e.g., withdrawal, transfer…) from the message queue and update the Merkle tree. Operations are packed into L2 Blocks.&lt;/p&gt;
&lt;p&gt;Rollup will periodically dump checkpoints (with message queue offsets). When the system restarts, it will load the state of Merkle tree from the last checkpoint, seek the corresponding offset in the message queue, and reprocess the messages in the message queue to recover the latest state.&lt;/p&gt;
&lt;h3&gt;Prover Cluster&lt;/h3&gt;
&lt;p&gt;After a L2 block is generated by the rollup state manager, a cryptographic proof is needed so that this block can be verified as correct on chain. This requires a prover cluster to provide desired computing power. What’s more, since the transaction volume of a DEX may vary considerably in different periods of time, this proof cluster needs to be highly scalable and elastic.&lt;/p&gt;
&lt;p&gt;To meet these requirements, we adopt the Master-Worker architecture, which consists of a stateful master node that manages a list of proving tasks, and a couple of stateless worker nodes that retrieve tasks from the master and submit proofs to the master after proving. Similar to PoW mining, since the computation for ZK-Rollup verification is much more lightweight than that of proving, we consider switching to a more “trustless” architecture in the future, so that miners can join and quit proving permissionlessly at any time. The cryptography behind can ensure that if a proof is validated (which can be checked quickly), the miner is not misbehaving.&lt;/p&gt;
&lt;p&gt;At present, prover cluster provides two different deployment styles - via Docker Compose and via K8S - to support local development/debugging and production environment deployment.&lt;/p&gt;
&lt;h2&gt;The Design Principles of FluiDex Back-end&lt;/h2&gt;
&lt;h3&gt;CQRS and Global Message Bus&lt;/h3&gt;
&lt;p&gt;The status update of a rollup system requires extremely strict consistency and accuracy – not even a slightest error is allowed. All status update operations should be traceable and recorded. To provide such reliable status updates, we adopt the &lt;a href=&quot;https://docs.microsoft.com/en-us/azure/architecture/patterns/cqrs&quot;&gt;CQRS&lt;/a&gt; design pattern. &lt;strong&gt;All writes to the global state are synchronized by a message queue.&lt;/strong&gt; Specifically, we use Kafka as the global message bus. The rollup system uses the message queue for the ground truth, receives notifications for status updates from the message queue, and update the global Merkle tree accordingly.&lt;/p&gt;
&lt;h3&gt;Memory-centric Data Maintenance&lt;/h3&gt;
&lt;p&gt;Conventional Internet services use databases for their data ground truths. They usually achieve their systems’ scalability and resilience through data sharding and stateless services.&lt;/p&gt;
&lt;p&gt;However, our ZK-Rollup system consists of many services that have to maintain a large number of complex data structures in memory (such as the rollup and the matching engine that maintains the Merkle tree and orderbook respectively). This requires an memory-centric architecture design. As a result, our design principles may differ from the &lt;a href=&quot;https://12factor.net/&quot;&gt;12 Factor&lt;/a&gt; recommended in many Internet business, but are more similar to game server developments.&lt;/p&gt;
&lt;h3&gt;Unified Technology Stack&lt;/h3&gt;
&lt;p&gt;Thanks to Rust’s type safety and ownership checks, as well as the performance comparable with C++, Rust has become the first choice for many cryptographic libraries, and the ecosystem has been exploding. Therefore, it is not surprising that we choose Rust for our rollup state manager and prover cluster. Besides, since a unified technology stack can greatly reduce our team’s cooperation overhead, other modules are also implemented in Rust.&lt;/p&gt;
&lt;h2&gt;Source Codes&lt;/h2&gt;
&lt;p&gt;FluiDex-backend has been open-sourced on Github and please refer to &lt;a href=&quot;https://github.com/fluidex/fluidex-backend&quot;&gt;https://github.com/fluidex/fluidex-backend&lt;/a&gt;. (Currently only with instructions on how to run it as a local cluster.) &lt;/p&gt;
&lt;div class=&quot;footnotes&quot;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&quot;fn-1&quot;&gt;
&lt;p&gt;using “grpc-&gt;websocket” but not implemented yet.&lt;/p&gt;
&lt;a href=&quot;#fnref-1&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;
&lt;/li&gt;
&lt;li id=&quot;fn-2&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://doc.rust-lang.org/stable/std/collections/struct.BTreeMap.html&quot;&gt;https://doc.rust-lang.org/stable/std/collections/struct.BTreeMap.html&lt;/a&gt;&lt;/p&gt;
&lt;a href=&quot;#fnref-2&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content:encoded></item><item><title><![CDATA[On the optimization of PlonK]]></title><description><![CDATA[Acknowledgement: we thank Ariel Gabizon, Daira Hopwood, Kobi Gurkan, Pratyush Mishra (in alphabetical order) for their kindly reviews and…]]></description><link>https://www.fluidex.io/en/blog/on-plonk/</link><guid isPermaLink="false">https://www.fluidex.io/en/blog/on-plonk/</guid><pubDate>Tue, 15 Jun 2021 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;&lt;em&gt;Acknowledgement: we thank Ariel Gabizon, Daira Hopwood, Kobi Gurkan, Pratyush Mishra (in alphabetical order) for their kindly reviews and insightful comments.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;In this article we brief three directions on optimizing PLONK, which is a polynomial interactive oracle proofs (IOP) zkSNARK systems. Proof systems other than using IOP also exist, for comparisons please refer to: &lt;a href=&quot;https://telaviv2019.scalingbitcoin.org/files/a-survey-of-progress-in-succinct-zero-knowledge-proofs-towards-trustless-snarks.pptx&quot;&gt;A Survey of Progress in Succinct Zero-Knowledge Proofs&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;The 3 layers of a polynomial IOP zkSNARK system&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Accumulation layer: &lt;em&gt;for Recursive Proof Composition&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;IOP layer: &lt;em&gt;PlonK core is here&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;Polynomial commitment layer: &lt;em&gt;for efficiently verifying polynomials&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Readers can gain a basic idea on the relationships between each layer from &lt;a href=&quot;https://electriccoin.co/blog/explaining-halo-2/&quot;&gt;https://electriccoin.co/blog/explaining-halo-2/&lt;/a&gt; (although it’s about Halo 2, it’s still helpful for understanding the relationships), so we would like to skip redundant explanations here.&lt;/p&gt;
&lt;h2&gt;The origin of PlonK&lt;/h2&gt;
&lt;p&gt;Out of the desire for a universal, programmable zkSNARK, &lt;a href=&quot;https://aztec.network/&quot;&gt;AZTEC&lt;/a&gt; invents and promotes the industry use of &lt;a href=&quot;https://eprint.iacr.org/2019/953.pdf&quot;&gt;PlonK&lt;/a&gt;. PlonK is flexible to build application-specific constraints, so that it strikes a balance between theoretical properties and engineering needs. Vitalik also wrote an awesome article explaining PlonK: &lt;a href=&quot;https://vitalik.ca/general/2019/09/22/plonk.html&quot;&gt;Understanding PLONK&lt;/a&gt;. You may also find some useful resources on &lt;a href=&quot;https://github.com/fluidex/awesome-plonk&quot;&gt;https://github.com/fluidex/awesome-plonk&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;PlonK has been popular since it went published. &lt;a href=&quot;https://zksync.io/&quot;&gt;zkSync&lt;/a&gt;, &lt;a href=&quot;https://dusk.network/&quot;&gt;Dusk Network&lt;/a&gt;, &lt;a href=&quot;https://minaprotocol.com/&quot;&gt;Mina&lt;/a&gt;, &lt;a href=&quot;https://mirprotocol.org/&quot;&gt;Mir&lt;/a&gt;, and &lt;a href=&quot;https://zcash.github.io/halo2/concepts/arithmetization.html&quot;&gt;Zcash’s Halo 2&lt;/a&gt;, are projects using PlonK or its variants.&lt;/p&gt;
&lt;h2&gt;The features of PlonK&lt;/h2&gt;
&lt;p&gt;PlonK supports universal and updateable setup, so &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This means two things: first, instead of there being one separate trusted setup for every program you want to prove things about, there is one single trusted setup for the whole scheme after which you can use the scheme with any program (up to some maximum size chosen when making the setup). Second, there is a way for multiple parties to participate in the trusted setup such that it is secure as long as any one of them is honest, and this multi-party procedure is fully sequential: first one person participates, then the second, then the third… The full set of participants does not even need to be known ahead of time; new participants could just add themselves to the end. This makes it easy for the trusted setup to have a large number of participants, making it quite safe in practice. --- taken from &lt;a href=&quot;https://vitalik.ca/general/2019/09/22/plonk.html&quot;&gt;Vitalik’s website&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Groth16 and other non-universal proof systems use rank-1 constraint system (R1CS) as the intermediate representation for their zkp circuits. PlonK is gate-based instead of R1CS-based, and transpiling from R1CS will likely be inefficient if using PlonK. For example, addition gates are cheap in R1CS-based systems, however which is not the case in gate-based systems.&lt;/p&gt;
&lt;p&gt;R1CS has the form (see the definitions in &lt;a href=&quot;https://eprint.iacr.org/2018/691.pdf&quot;&gt;[WZC+ 18]&lt;/a&gt; or &lt;a href=&quot;https://eprint.iacr.org/2021/651.pdf&quot;&gt;[CWC+ 21]&lt;/a&gt;):&lt;/p&gt;
&lt;!-- 
$$\sum_{i\in [N]}(a_{i,j}\ x_i) \cdot \sum_{i\in [N]}(b_{i,j}\ x_i) = \sum_{i\in [N]}(c_{i,j}\ x_i)$$
 --&gt;
&lt;img src=&quot;https://latex.codecogs.com/svg.image?\sum_{i\in&amp;amp;space;[N]}(a_{i,j}\&amp;amp;space;x_i)&amp;amp;space;\cdot&amp;amp;space;\sum_{i\in&amp;amp;space;[N]}(b_{i,j}\&amp;amp;space;x_i)&amp;amp;space;=&amp;amp;space;\sum_{i\in&amp;amp;space;[N]}(c_{i,j}\&amp;amp;space;x_i)&quot; title=&quot;\sum_{i\in [N]}(a_{i,j}\ x_i) \cdot \sum_{i\in [N]}(b_{i,j}\ x_i) = \sum_{i\in [N]}(c_{i,j}\ x_i)&quot;&gt;
&lt;p&gt;However, PlonK using a constraint system in the form of:&lt;/p&gt;
&lt;!-- 
$$(q_L)_i \cdot x_{a_i} + (q_R)_i \cdot x_{b_i} + (q_O)_i \cdot x_{c_i} + (q_M)_i \cdot (x_{a_i} x_{b_i}) + (q_C)_i = 0$$
 --&gt;
&lt;img src=&quot;https://latex.codecogs.com/svg.image?(q_L)_i&amp;amp;space;\cdot&amp;amp;space;x_{a_i}&amp;amp;space;+&amp;amp;space;(q_R)_i&amp;amp;space;\cdot&amp;amp;space;x_{b_i}&amp;amp;space;+&amp;amp;space;(q_O)_i&amp;amp;space;\cdot&amp;amp;space;x_{c_i}&amp;amp;space;+&amp;amp;space;(q_M)_i&amp;amp;space;\cdot&amp;amp;space;(x_{a_i}&amp;amp;space;x_{b_i})&amp;amp;space;+&amp;amp;space;(q_C)_i&amp;amp;space;=&amp;amp;space;0&quot; title=&quot;(q_L)_i \cdot x_{a_i} + (q_R)_i \cdot x_{b_i} + (q_O)_i \cdot x_{c_i} + (q_M)_i \cdot (x_{a_i} x_{b_i}) + (q_C)_i = 0&quot;&gt;
&lt;p&gt;PlonK focuses on constant fan-in circuits, and its linear constraints can be reduced to a permutation check, which can be more simply combined than general linear constraints. &lt;a href=&quot;https://hackmd.io/@aztec-network/plonk-arithmetiization-air#How-does-all-this-relate-to-R1CS&quot;&gt;From AIRs to RAPs - how PLONK-style arithmetization works&lt;/a&gt; discusses the advantages and disadvantages of them. In a word, PlonK is more flexible (e.g., it allows constraints of degree larger than two, comparing to R1CS) and allows writing application-specific programs.&lt;/p&gt;
&lt;p&gt;Therefore, it’d be more efficient if constructing from gates in PlonK, instead of transpiling from R1CS.&lt;/p&gt;
&lt;h2&gt;Optimizing PlonK on IOP layer&lt;/h2&gt;
&lt;p&gt;We could also work from the three layers mentioned above to optimize PlonK.&lt;/p&gt;
&lt;p&gt;For example, on the IOP layer, we could use custom gates (in Plonk you could flexibly DIY constraints) to define bit arithmetic operations, including EC point addition, Poseidon hashes, Pedersen hashes, 8-bit XOR, and so on, to save the proving computations.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://eprint.iacr.org/2020/315.pdf&quot;&gt;Plookup&lt;/a&gt; (PlonK with lookup table) is a further optimization. It enables lookup table in PlonK circuits, so that you can precompute a lookup table of the legitimate (input, output) combinations, and prove a witness existing in the table, instead of proving the witness itself. This means we can use lookup tables to help the computations that were SNARK-unfriendly originally. For example, without lookup tables, SNARKs is not friendly to bit operations: because we will have to compute bit-by-bit; but with lookup tables, we can now store the result of an 8-bit operation in a table to lookup and access, avoiding computing bit-by-bit again. (You can think of it as compute 8 bits at a time.)&lt;/p&gt;
&lt;p&gt;Plookup can also be extended to vector lookups and multiple tables, bringing huge benefits to circuit programming models involving dynamic memory (e.g., vectors &amp;#x26; dynamic array). A use case is to build zkEVM on top of it, proving the execution and the correctness of the execution.&lt;/p&gt;
&lt;p&gt;AZTEC’s “Turbo-PlonK” is “PlonK + custom gate”, and its “Ultra-PlonK” is “PlonK (+ custom gate) + Plookup”. According to their benchmarks(&lt;a href=&quot;https://medium.com/aztec-protocol/plonk-benchmarks-2-5x-faster-than-groth16-on-mimc-9e1009f96dfe&quot;&gt;[1]&lt;/a&gt;, &lt;a href=&quot;https://medium.com/aztec-protocol/plonk-benchmarks-ii-5x-faster-than-groth16-on-pedersen-hashes-ea5285353db0&quot;&gt;[2]&lt;/a&gt;, &lt;a href=&quot;https://medium.com/aztec-protocol/aztecs-zk-zk-rollup-looking-behind-the-cryptocurtain-2b8af1fca619&quot;&gt;[3]&lt;/a&gt;, &lt;a href=&quot;https://www.youtube.com/watch?v=Vdlc1CmRYRY&amp;#x26;t=1560s&quot;&gt;[4]&lt;/a&gt;), they achieve considerable improvements by integrating custom gates and Plookup.&lt;/p&gt;
&lt;h2&gt;Optimization on accumulation layer&lt;/h2&gt;
&lt;p&gt;Another great technique is recursive proof composition: it has such a nice feature that you can recursively aggregate several proofs into a single proof while still keeping it succinct, and you can verify them all in one go.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://eprint.iacr.org/2019/1021.pdf&quot;&gt;Halo&lt;/a&gt; is probably the first notable efficient recursive zkp scheme without requiring a trusted setup, which inspires many future works. &lt;a href=&quot;https://eprint.iacr.org/2020/499.pdf&quot;&gt;[BCMS20]&lt;/a&gt; formalizes&amp;#x26;generalizes this technique and calls it “accumulation scheme”.&lt;/p&gt;
&lt;p&gt;PlonK can use custom gate for prime field arithmetic, which means it will be quite convenient and efficient to implement Halo-style recursion in PlonK. This is an optimization technique on accumulation layer.&lt;/p&gt;
&lt;h2&gt;Optimization on polynomial commitment layer&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://eprint.iacr.org/2020/081.pdf&quot;&gt;SHPLONK&lt;/a&gt; is an optimization on polynomial commitment layer, which can work with PlonK to achieve smaller proof size and shorter proving time. Other protocols aiming at optimizing polynomial commitment also exist. (Or alternatively, inspired by FRI, &lt;a href=&quot;https://eprint.iacr.org/2019/1400.pdf&quot;&gt;REDSHIFT&lt;/a&gt; uses List Polynomial Commitment to turn PlonK into a zkSTARK, which increases the proof size but reduces the proving time and removes the need for a trusted setup.)&lt;/p&gt;</content:encoded></item><item><title><![CDATA[浅谈提升 PlonK]]></title><description><![CDATA[致谢：感谢 Ariel Gabizon, Daira Hopwood, Kobi Gurkan, Pratyush Mishra 给我们提供的宝贵意见！（名字按字母序排序） 在这篇文章中，我们简要阐述了优化 PlonK 的三个方向。PlonK 是一个 polynomial…]]></description><link>https://www.fluidex.io/zh/blog/on-plonk/</link><guid isPermaLink="false">https://www.fluidex.io/zh/blog/on-plonk/</guid><pubDate>Tue, 15 Jun 2021 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;&lt;em&gt;致谢：感谢 Ariel Gabizon, Daira Hopwood, Kobi Gurkan, Pratyush Mishra 给我们提供的宝贵意见！（名字按字母序排序）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;在这篇文章中，我们简要阐述了优化 PlonK 的三个方向。PlonK 是一个 polynomial interactive oracle proofs (IOP) zkSNARK system。其他非 IOP 的 zkSNARK system 也存在，参见 &lt;a href=&quot;https://telaviv2019.scalingbitcoin.org/files/a-survey-of-progress-in-succinct-zero-knowledge-proofs-towards-trustless-snarks.pptx&quot;&gt;A Survey of Progress in Succinct Zero-Knowledge Proofs&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;Polynomial IOP zkSNARK system 的三个 layer&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Accumulation layer: &lt;em&gt;用于 Recursive Proof Composition （递归证明）&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;IOP layer: &lt;em&gt;PlonK 的核心&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;Polynomial commitment layer: &lt;em&gt;快速验证多项式&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://electriccoin.co/blog/explaining-halo-2/&quot;&gt;https://electriccoin.co/blog/explaining-halo-2/&lt;/a&gt; 是一篇有助于理解各层级之间关系的很好的文章（虽然讲的是 Halo 2，但对于理解层级关系亦有帮助），在此不再赘述。&lt;/p&gt;
&lt;h2&gt;PlonK 的源起&lt;/h2&gt;
&lt;p&gt;出于对通用的、可编程的 zkSNARK 的需要，&lt;a href=&quot;https://aztec.network/&quot;&gt;AZTEC&lt;/a&gt; 发明并推动了 &lt;a href=&quot;https://eprint.iacr.org/2019/953.pdf&quot;&gt;PlonK&lt;/a&gt;。PlonK 能用于灵活地构建专用的约束，在理论和工程之间取得了极好的平衡。V 神 的 &lt;a href=&quot;https://vitalik.ca/general/2019/09/22/plonk.html&quot;&gt;Understanding PLONK&lt;/a&gt; 一文是 PlonK 很好的入门文章，更多的资料也可以访问 &lt;a href=&quot;https://github.com/fluidex/awesome-plonk&quot;&gt;https://github.com/fluidex/awesome-plonk&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;PlonK 面世之后很受欢迎，&lt;a href=&quot;https://zksync.io/&quot;&gt;zkSync&lt;/a&gt;、&lt;a href=&quot;https://dusk.network/&quot;&gt;Dusk Network&lt;/a&gt;、&lt;a href=&quot;https://minaprotocol.com/&quot;&gt;Mina&lt;/a&gt;、&lt;a href=&quot;https://mirprotocol.org/&quot;&gt;Mir&lt;/a&gt; 和 &lt;a href=&quot;https://zcash.github.io/halo2/concepts/arithmetization.html&quot;&gt;Zcash’s Halo 2&lt;/a&gt; 都在使用 PlonK 或者 PlonK 的变种。&lt;/p&gt;
&lt;h2&gt;PlonK 的特点&lt;/h2&gt;
&lt;p&gt;PlonK 的特点就是可以支持 通用的 和 可更新的设置。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这意味着两点：首先，你不需要再为每一个想要证明的程序进行单独的可信设置，而只需要进行一次可信设置，然后就可以用于任何（不超过一定大小的）程序。第二，在可信设置中可以有多方参与，那么只要有一个人是诚实的，协议就是安全的。并且这个多方参与的过程可以是一个个来的：首先第一个人参与进来，然后第二个，然后第三个…事先不需要知道都有谁参与进来；新的加入者完全可以加入到队伍的末尾。这就使得可信设置能很简单地就能有很多参与者，使得实践中达到很高的安全度。 --- 译 &lt;a href=&quot;https://vitalik.ca/general/2019/09/22/plonk.html&quot;&gt;Vitalik 的博客&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Groth16 等非通用的证明系统中使用 rank-1 constraint system (R1CS) 作为 intermediate representation 来对电路进行抽象表示。PlonK 是基于 gate 而不是基于 R1CS 的，所以从 R1CS 转译不会那么高效。比如说，R1CS 中加法门电路的开销比较低，但在 PlonK 中则不是如此。&lt;/p&gt;
&lt;p&gt;R1CS 形如 (&lt;a href=&quot;https://eprint.iacr.org/2018/691.pdf&quot;&gt;[WZC+ 18]&lt;/a&gt; 和 &lt;a href=&quot;https://eprint.iacr.org/2021/651.pdf&quot;&gt;[CWC+ 21]&lt;/a&gt; 有对其进行形式化定义):&lt;/p&gt;
&lt;!-- 
$$\sum_{i\in [N]}(a_{i,j}\ x_i) \cdot \sum_{i\in [N]}(b_{i,j}\ x_i) = \sum_{i\in [N]}(c_{i,j}\ x_i)$$
 --&gt;
&lt;img src=&quot;https://latex.codecogs.com/svg.image?\sum_{i\in&amp;amp;space;[N]}(a_{i,j}\&amp;amp;space;x_i)&amp;amp;space;\cdot&amp;amp;space;\sum_{i\in&amp;amp;space;[N]}(b_{i,j}\&amp;amp;space;x_i)&amp;amp;space;=&amp;amp;space;\sum_{i\in&amp;amp;space;[N]}(c_{i,j}\&amp;amp;space;x_i)&quot; title=&quot;\sum_{i\in [N]}(a_{i,j}\ x_i) \cdot \sum_{i\in [N]}(b_{i,j}\ x_i) = \sum_{i\in [N]}(c_{i,j}\ x_i)&quot;&gt;
&lt;p&gt;PlonK 则形如：&lt;/p&gt;
&lt;!-- 
$$(q_L)_i \cdot x_{a_i} + (q_R)_i \cdot x_{b_i} + (q_O)_i \cdot x_{c_i} + (q_M)_i \cdot (x_{a_i} x_{b_i}) + (q_C)_i = 0$$
 --&gt;
&lt;img src=&quot;https://latex.codecogs.com/svg.image?(q_L)_i&amp;amp;space;\cdot&amp;amp;space;x_{a_i}&amp;amp;space;+&amp;amp;space;(q_R)_i&amp;amp;space;\cdot&amp;amp;space;x_{b_i}&amp;amp;space;+&amp;amp;space;(q_O)_i&amp;amp;space;\cdot&amp;amp;space;x_{c_i}&amp;amp;space;+&amp;amp;space;(q_M)_i&amp;amp;space;\cdot&amp;amp;space;(x_{a_i}&amp;amp;space;x_{b_i})&amp;amp;space;+&amp;amp;space;(q_C)_i&amp;amp;space;=&amp;amp;space;0&quot; title=&quot;(q_L)_i \cdot x_{a_i} + (q_R)_i \cdot x_{b_i} + (q_O)_i \cdot x_{c_i} + (q_M)_i \cdot (x_{a_i} x_{b_i}) + (q_C)_i = 0&quot;&gt;
&lt;p&gt;PlonK 着重于固定输入数的电路，且它的线性约束可以归约到一个 permutation check（置换检查），比起一般的线性约束，结合起来简单很多。&lt;a href=&quot;https://hackmd.io/@aztec-network/plonk-arithmetiization-air#How-does-all-this-relate-to-R1CS&quot;&gt;From AIRs to RAPs - how PLONK-style arithmetization works&lt;/a&gt; 讨论了 R1CS 和 PlonK 中 gate 约束的优缺点。简单来说，PlonK 更加灵活（比如说它可以支持高次的约束）并使得针对应用写专用电路成为可能。&lt;/p&gt;
&lt;p&gt;所以，如果采用 PlonK 的话，从 gates 构造会比从 R1CS 转译实现起来高效很多。&lt;/p&gt;
&lt;p&gt;在此基础上，PlonK 的性能还有提升的空间，比如我们可以从前面提到的 3 个 layer 来进行优化。&lt;/p&gt;
&lt;h2&gt;IOP layer 的优化&lt;/h2&gt;
&lt;p&gt;在 IOP layer，我们可以使用 custom gate，以进行自定义 bit arithmetic operations，包括 EC point addition、Poseidon hashes、Pedersen hashes、8-bit 逻辑异或。这一切会使得运算变得很高效。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://eprint.iacr.org/2020/315.pdf&quot;&gt;Plookup&lt;/a&gt; (PlonK with lookup table) 是通过 custom 实现的进一步的优化。Plookup 找到了一种方式在 PlonK 的电路中高效实现 lookup table，你可以预先计算一个 lookup table，并证明一个 witness 在这个表中，而不需要再去证明这个 witness 本身。这样 lookup tables 就可以用来改善原本是 SNARK-unfriendly 的计算。简单来说，SNARK 本身对于位运算并不友好：你需要一个个 bit 地操作。但 lookup tables 就可以解决这个问题：你不必再每一位每一位地运算，你可以比如说将你的 8-bit 的计算结果储存在一个大表中进行查找，这样就可以一次运算 8-bit 而不必每一 bit 每一 bit 地运算。&lt;/p&gt;
&lt;p&gt;Plookup 还可以用于实现动态内存（vector / 动态数组），对于更灵活的电路编程模型大有裨益：比如实现零知识证明电路虚拟机，可以用于证明执行了指令及执行的正确性，以支持智能合约。&lt;/p&gt;
&lt;p&gt;AZTEC 的 Turbo-PlonK 就是在 PlonK 的基础上加上 custom gate，然后再在此之上实现 Plookup 就是 AZTEC 的 Ultra-PlonK。AZTEC 的 benchmarks(&lt;a href=&quot;https://medium.com/aztec-protocol/plonk-benchmarks-2-5x-faster-than-groth16-on-mimc-9e1009f96dfe&quot;&gt;[1]&lt;/a&gt;, &lt;a href=&quot;https://medium.com/aztec-protocol/plonk-benchmarks-ii-5x-faster-than-groth16-on-pedersen-hashes-ea5285353db0&quot;&gt;[2]&lt;/a&gt;, &lt;a href=&quot;https://medium.com/aztec-protocol/aztecs-zk-zk-rollup-looking-behind-the-cryptocurtain-2b8af1fca619&quot;&gt;[3]&lt;/a&gt;, &lt;a href=&quot;https://www.youtube.com/watch?v=Vdlc1CmRYRY&amp;#x26;t=1560s&quot;&gt;[4]&lt;/a&gt;) 表明他们通过 custom gates and Plookup 得到了很可观的性能提升。&lt;/p&gt;
&lt;h2&gt;Accumulation layer 的优化&lt;/h2&gt;
&lt;p&gt;Recursive-SNARK 的良好特性也被人注意到，越来越多协议想要使用。使用 recursive proof composition 你可以将多个 proof 归集到一个 proof 中，一次性对所有 proof 进行证明/验证，并保持证明的简洁性。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://eprint.iacr.org/2019/1021.pdf&quot;&gt;Halo&lt;/a&gt; 可以说是第一个有实践意义的 recursive 零知识证明协议，启发了很多后续的工作。&lt;a href=&quot;https://eprint.iacr.org/2020/499.pdf&quot;&gt;[BCMS20]&lt;/a&gt; 对其进行了形式化、扩展，并将其命名为 “accumulation scheme”。&lt;/p&gt;
&lt;p&gt;PlonK 对于想要改造并使用 Halo-style recursion 其实也挺友好，因为可以用 custom gate 来做 Halo 中的 prime field operations（质数域算术运算）。&lt;/p&gt;
&lt;p&gt;这属于 accumulation layer 的优化。&lt;/p&gt;
&lt;h2&gt;Polynomial commitment layer 的优化&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://eprint.iacr.org/2020/081.pdf&quot;&gt;SHPLONK&lt;/a&gt; 是对 polynomial commitment layer 的优化，能结合在 PlonK 上使用，达到减小 proof 体积和证明所需要的时间。别的一些论文也有对 polynomial commitment 进行的优化。（或者，如果你采用受 FRI 启发、用了 List Polynomial Commitment 的 &lt;a href=&quot;https://eprint.iacr.org/2019/1400.pdf&quot;&gt;REDSHIFT&lt;/a&gt; 的话，就可以将 PlonK 变成一个 zkSTARK。虽然会增加 proof 体积，但能减少证明所需要的时间，并免除可信设置。）&lt;/p&gt;</content:encoded></item><item><title><![CDATA[FluiDex 2021-05 Updates]]></title><description><![CDATA[About Us: FluiDex team is working on building the first zk-rollup layer2 order-book DEX with permissionless listings on Ethereum. For a more…]]></description><link>https://www.fluidex.io/en/blog/2021-05-27-updates/</link><guid isPermaLink="false">https://www.fluidex.io/en/blog/2021-05-27-updates/</guid><pubDate>Fri, 28 May 2021 09:00:00 GMT</pubDate><content:encoded>&lt;p&gt;About Us: FluiDex team is working on building the first zk-rollup layer2 order-book DEX with permissionless listings on Ethereum. For a more comprehensive introduction to the project, please see our &lt;a href=&quot;/en/blog/fluidex-a-zkrollup-layer2-dex/&quot;&gt;previous article&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In this post, we are happy to share our progress in the last two months.&lt;/p&gt;
&lt;h2&gt;Added more zkp development toolkits&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/fluidex/plonkit&quot;&gt;&lt;strong&gt;Plonkit&lt;/strong&gt;&lt;/a&gt;, the PLONK zero-knowledge proof toolkit developed by the FluiDex team, has become an important part of the team’s daily development life, and boosts our outputs considerably. In the past a few months, we have also added more new tools into our development ecosystem.&lt;/p&gt;
&lt;h3&gt;Snarkit: an enhanced circom compiler &amp;#x26; debugger&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Snarkit&lt;/strong&gt; is aiming at making the development of circuits as easy as in other programming languages. We hope that, with &lt;strong&gt;Snarkit&lt;/strong&gt;’s ability to report errors with higher accuracy and in details, people can easily abstract and reuse circuit codes in a high level. Currently, &lt;strong&gt;Snarkit&lt;/strong&gt; is only available in Circom, and its features concentrate on circuit testing. For example, for any given circuit codes and anticipated input/output, &lt;strong&gt;Snarkit&lt;/strong&gt; will check whether the input fits into the circuit and whether the output fulfills the expectation. If &lt;strong&gt;Snarkit&lt;/strong&gt; detects any unexpected errors, it will list out the module location and the Line Number of Error, as well as the variables related to the errors. &lt;strong&gt;Snarkit&lt;/strong&gt; supports two types of backend: wasm and C++. The  wasm backend can work without any other prerequisites, while C++ backend can support larger circuits with higher performance. Please note that the C++ backend only supports the latest x64 CPU. (Thanks to the high-performance finite field operation codes in circom, ffwasm, ffiasm.)&lt;/p&gt;
&lt;p&gt;Github link: &lt;a href=&quot;https://github.com/fluidex/snarkit&quot;&gt;https://github.com/fluidex/snarkit&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;PLONK Prover Cluster&lt;/h3&gt;
&lt;p&gt;A ZK-Rollup system usually &lt;a href=&quot;/en/blog/zkrollup-intro1/&quot;&gt;needs hundred of servers to perform cryptography computations when proving&lt;/a&gt;. Such a burden of computation asks for a comprehensive platform for task coordination. In this context, we developed &lt;strong&gt;PLONK Prover Cluster&lt;/strong&gt;, to deploy a mass cluster of nodes for proving tasks according to specific settings. &lt;strong&gt;PLONK Prover Cluster&lt;/strong&gt; uses “master-slaves” architecture and uses k8s for coordination and resilience; it also support debugging using docker-compose locally. For now it suits the best with elastic cloud services such as Aliyun Serverless Kubernetes. But we are also considering applying cloud platform native API (such as EC2 Auto Scaling) for more flexible and cost-effective solutions.&lt;/p&gt;
&lt;p&gt;Better cooperate with &lt;a href=&quot;https://github.com/fluidex/plonkit&quot;&gt;Plonkit&lt;/a&gt; BTW.&lt;/p&gt;
&lt;p&gt;Github link: &lt;a href=&quot;https://github.com/fluidex/prover-cluster&quot;&gt;https://github.com/fluidex/prover-cluster&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Progress on FluiDex Exchange&lt;/h2&gt;
&lt;h3&gt;Circuits&lt;/h3&gt;
&lt;p&gt;Essential functions of the exchange (such as deposit, transfer, trade, withdrawal, etc.) are almost finished. By merging common logic of L2 transactions (such as the Merkle proof), we manage to reduce over 1/3 of the overhead. After this optimization, our system, if assuming with one million (2**20) users and one million (2**20) tokens, can handle more than 600 L2 transactions, with 2**28 circuit constraints. At present, a single transaction comes with 420k circuit constraints. We will keep working on the optimization.&lt;/p&gt;
&lt;p&gt;Github link: &lt;a href=&quot;https://github.com/fluidex/circuits&quot;&gt;https://github.com/fluidex/circuits&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Rollup Operator&lt;/h3&gt;
&lt;p&gt;A Rollup needs semi-decentralized node(s) to collect all layer2 transactions, update rollup state, and generate layer-2 blocks. Such a node is usually called an Operator, a Sequencer, or a State-Updaters. Recently, we implement an operator in Rust to work with our FluiDex circuits. For a system with 2**20 users and 2**20 tokens, the operator can update the Merkle trees concurrently with a speed up to 250 TPS. &lt;/p&gt;
&lt;p&gt;Github link: &lt;a href=&quot;https://github.com/fluidex/rollup-state-manager&quot;&gt;https://github.com/fluidex/rollup-state-manager&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Matching Engine&lt;/h3&gt;
&lt;p&gt;We integrated “post-only order” feature so that market-makers can avoid undesirable loss on transaction fees or commissions due to price fluctuation. We also added an inner transfer feature to the existing engine. &lt;/p&gt;
&lt;p&gt;Github link: &lt;a href=&quot;https://github.com/fluidex/dingir-exchange&quot;&gt;https://github.com/fluidex/dingir-exchange&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Research&lt;/h2&gt;
&lt;p&gt;We published an aricle &lt;a href=&quot;/zh/blog/damm/&quot;&gt;“Differential AMM: a highly flexible AMM algorithm based on micro indicators”&lt;/a&gt;. To put it simply, DAMM is a flexible AMM design that built from micro-indicators, such as the average market price and market depth. Creators of the AMM pool can freely adjust the market-making parameters (such as price range, liquidity depth, market cap, capital efficiency) according to their strategies. Besides, we gave out a reference implementation (only an PoC) on translating DAMM into orderbook. FluiDex will embed this DAMM feature at the end, and the liquidity of each trade pair will be supported by both orderbook and AMM.&lt;/p&gt;
&lt;h2&gt;Community Activities&lt;/h2&gt;
&lt;p&gt;On April 20th, Shanghai Advanced Technology Seminar was held under the theme of “Zero-Knowledge Proof”. Zhuo ZHANG, Founder of the Fuildex, was invited to deliver a keynote on “ZK-Rollup Development Experience Sharing”. Also invited to the seminar were Yu GUO, Founder of the SECBIT Labs, and YAO Xiang, Tech Ambassador of Mina in Asia. Guo and Yao talked about “ZKCP+ Zero-knowledge Proof and Fair (Data) Exchange Protocol” and “Snapps Architecture and its Application”, respectively.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[FluiDex 2021年5月 开发进展]]></title><description><![CDATA[关于我们：FluiDex 团队正在开发 Ethereum 上第一个无许可上币的 ZK-Rollup layer2 订单簿 DEX…]]></description><link>https://www.fluidex.io/zh/blog/2021-05-27-updates/</link><guid isPermaLink="false">https://www.fluidex.io/zh/blog/2021-05-27-updates/</guid><pubDate>Fri, 28 May 2021 09:00:00 GMT</pubDate><content:encoded>&lt;p&gt;关于我们：FluiDex 团队正在开发 Ethereum 上第一个无许可上币的 ZK-Rollup layer2 订单簿 DEX。项目的完整介绍可以看&lt;a href=&quot;/zh/blog/fluidex-a-zkrollup-layer2-dex/&quot;&gt;这篇文章&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;下面介绍最近两个月，团队在各方面的工作进展。&lt;/p&gt;
&lt;!--
## 新版官网上线

我们重新设计了 FluiDex 项目的风格样式，新的官网已经更新在了 &lt;https://www.fluidex.io/&gt;

![](/media/new_website_0528.png)

--&gt;
&lt;h2&gt;更多的零知识证明开发工具&lt;/h2&gt;
&lt;p&gt;我们开发了一些新的开发工具包，这些工具已经成为 FluiDex 团队日常开发流程的一部分，极大地提升了团队的开发效率。&lt;/p&gt;
&lt;h3&gt;电路开发调试工具 snarkit&lt;/h3&gt;
&lt;p&gt;我们希望零知识证明电路的开发最终能够像普通软件开发一样简单，例如代码能够允许较高层次的复用和抽象，出错时能够给出准确的报错位置和原因。这就是我们开发 snarkit 的初衷。snarkit 目前仅支持 circom 语言，最重要的功能是电路测试，即给定电路代码和预期的输入输出，检查输入是否满足电路约束，输出是否满足预期。如果出现任何未预期的错误，则会显示出报错的模块和行号，也会显示报错位置相关的具体变量值。&lt;/p&gt;
&lt;p&gt;snarkit 支持两种 backend，wasm 的 backend 不需要安装任何依赖方便快速上手使用，c++ 的 backend 支持大型电路并且性能更高，仅支持较新的 x64 CPU。（感谢circom/ffwasm/ffiasm 的高性能底层有限域代码）&lt;/p&gt;
&lt;p&gt;代码位置：&lt;a href=&quot;https://github.com/fluidex/snarkit&quot;&gt;https://github.com/fluidex/snarkit&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;零知识证明集群 PLONK Prover Cluster&lt;/h3&gt;
&lt;p&gt;ZK-Rollup 系统一般会需要 &lt;a href=&quot;/zh/blog/zkrollup-intro1/&quot;&gt;多达几百台服务器来完成证明计算&lt;/a&gt;。这需要一个完善的资源编排调度平台。我们开发了 Plonk Prover Cluster，能够按照配置启动一个大规模的集群完成证明计算。系统采用了单 master + 多 slave 的架构设计，基于 k8s 完成动态伸缩和调度，也支持本地使用 docker-compose 来做单机开发调试。目前较适合于部署在 Aliyun Serverless Kubernetes 这种弹性平台上，我们未来会进一步考虑使用 cloud platform native API (如 EC2 Auto Scaling） 来实现更灵活和有性价比的方案。&lt;/p&gt;
&lt;p&gt;Plonk Prover Cluster 适合结合 FluiDex 团队之前的 PLONK DSL 开发工具 &lt;a href=&quot;https://github.com/fluidex/plonkit&quot;&gt;Plonkit&lt;/a&gt; 使用。&lt;/p&gt;
&lt;p&gt;代码位置：&lt;a href=&quot;https://github.com/fluidex/prover-cluster&quot;&gt;https://github.com/fluidex/prover-cluster&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;FluiDex 交易所的开发&lt;/h2&gt;
&lt;h3&gt;电路&lt;/h3&gt;
&lt;p&gt;充值/转账/交易/提币 等基础功能已经基本完成。我们通过把不同 l2 交易中共用的计算逻辑（如 merkle proof）提取到外层，优化掉了超过 1/3 的电路规模。对于一个一百万(2**20)用户数量，一百万 token (2**20)数量的 ZK-Rollup 系统，2**28 个 plonk 门约束的容量下能够容纳超过 600 个 l2 交易，单个交易需要的门约束目前为 420k 门约束。我们未来会进一步优化 layer2 tx 的资源消耗量。&lt;/p&gt;
&lt;p&gt;代码位置：&lt;a href=&quot;https://github.com/fluidex/circuits&quot;&gt;https://github.com/fluidex/circuits&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Rollup Operator&lt;/h3&gt;
&lt;p&gt;Rollup 需要一个半中心化的后台节点，用来收集所有的 layer2 交易，更新状态，并且生成 layer2 block，一般可以被称为 Operator / Sequencer / StateUpdater 等。我们使用 Rust 实现了配合 FluiDex 电路使用的 Operator，目前在 2**20 个用户和 token 的系统中，通过 &lt;a href=&quot;https://github.com/fluidex/rollup-state-manager/blob/b6c049208e17a4916b12ff0ab23e7699df7f231e/src/state/global.rs#L270&quot;&gt;并行更新 merkle tree&lt;/a&gt; 能够达到约 250 TPS。&lt;/p&gt;
&lt;p&gt;代码位置：&lt;a href=&quot;https://github.com/fluidex/rollup-state-manager&quot;&gt;https://github.com/fluidex/rollup-state-manager&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;撮合引擎&lt;/h3&gt;
&lt;p&gt;增加了 post-only order 以允许做市商限制自己的做市订单类型，避免因为盘口价格波动造成返佣和手续费损失。
增加了 inner transfer 功能。&lt;/p&gt;
&lt;p&gt;代码位置：&lt;a href=&quot;https://github.com/fluidex/dingir-exchange&quot;&gt;https://github.com/fluidex/dingir-exchange&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;算法设计研究&lt;/h2&gt;
&lt;p&gt;我们完成了&lt;a href=&quot;/zh/blog/damm/&quot;&gt;《Differential AMM: 一种基于微观指标设计的灵活 AMM 算法》&lt;/a&gt;。这是一种从微观指标（如盘口中间价和盘口深度）入手的灵活 AMM 设计，AMM 资金池的创建者能够任意调整设定 自动做市价格范围/流动性深度/做市资金量/资金效率 等指标。我们还给出了 DAMM 转化为订单簿的参考代码实现。FluiDex 最终完成版本中将会集成 DAMM，每种交易对的流动性都由 Orderbook 和 AMM 混合而成 。&lt;/p&gt;
&lt;h2&gt;社区交流&lt;/h2&gt;
&lt;p&gt;在 4 月 20 日的 上海前沿技术研讨会 以零知识证明为专题。FluiDex 创始人张卓和安比实验室创始人郭宇，Mina 亚洲技术大使姚翔分别做了题目《ZK-Rollup 工程实践》《ZKCP+ 零知识证明与公平数据交易协议》和 《Snapps架构和应用》三场分享。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Differential AMM: a highly flexible AMM algorithm based on micro indicators]]></title><description><![CDATA[TL;DR: We propose a Differential Automated Market Makers strategy improved on Constant-Function Market Makers (CFMM) strategy and its…]]></description><link>https://www.fluidex.io/en/blog/damm/</link><guid isPermaLink="false">https://www.fluidex.io/en/blog/damm/</guid><pubDate>Wed, 19 May 2021 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;&lt;strong&gt;TL;DR:&lt;/strong&gt; We propose a Differential Automated Market Makers strategy improved on Constant-Function Market Makers (CFMM) strategy and its variances, by using micro indicators (price, depth, price range&lt;sup id=&quot;fnref-1&quot;&gt;&lt;a href=&quot;#fn-1&quot; class=&quot;footnote-ref&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;, and etc.), rather than the product of two pools’ sizes in orginal CFMMs. This gives a more intuitive way to reflect the market, and is more friendly to market making.&lt;/p&gt;
&lt;p&gt;Automatic Market-Making (AMM) strategies are usually defined by macro indicators. Macro indicators refer to indicators that describe the total amount, including the base amount (BA) and the quote amount (QA) of the trading tokens in the AMM pool. For example, the most common AMM algorithm - the Constant Product Algorithm - requires the product of BA and QA to be equal both before and after each transaction. But in fact, for a real-world trader, micro indicators are more informative for each trade decision making. Micro indicators refer to indicators that characterize market changes, or marginal effects of transactions, such as current market price and market depth. The market price describes the average deal price of a relatively small-volume transaction in the current state, and the market depth describes the largest potential trading volume within an offered price. In plain language, assume that the price of ETH is now 3450 USDT, if I want to buy as much ETH as possible at a price not exceeding 3451, the amount of ETH I could buy can be regarded as the market depth.&lt;/p&gt;
&lt;p&gt;From the orderbook perspective, both price and depth are more intuitive than macro indicators. We here try to design a better AMM algorithm based on these two micro indicators. &lt;/p&gt;
&lt;h1&gt;Mathematical Background - The relationship between macro and micro indicators&lt;/h1&gt;
&lt;p&gt;In this section, we will explain the relationship between the micro indicators (price and depth) and the base/quote amount (pool size). As we will see, the formulas of price and depth can both be derived from the base/quote amount formulas by several derivative/inverse function transformations.&lt;/p&gt;
&lt;p&gt;Assume that base amount and quote amount in AMM pool satisfy the following relationship:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;quote = f(base)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Obviously, we have quote &gt; 0, base &gt; 0. f is monotonically decreasing, i.e., f’ &amp;#x3C; 0 (as in each trade in an AMM pool, a token is turned into another token; if the amount of one token increases, the other will of course decrease).&lt;/p&gt;
&lt;p&gt;By definition, price is the absolute value of the derivative of f (as f’ is negative, it’s actually the reverse value of f’):&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;price = abs(f&amp;#39;(base)) = -f&amp;#39;(base)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Normally we require the price, -f’, to be monotonically decreasing, i.e., the smaller the base amount, the higher the price. Thus, f” &gt; 0. In a word, a reasonable f should be: a convex downward and monotonically decreasing function defined in the first quadrant.&lt;/p&gt;
&lt;p&gt;Correspondingly, market depth is actually the derivative of base amount w.r.t. price.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;depth = f2&amp;#39;(price)
f2 = Inverse(f&amp;#39;) &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Where &lt;code class=&quot;language-text&quot;&gt;Inverse&lt;/code&gt; means inverse function.&lt;/p&gt;
&lt;p&gt;In the above formula, f2 is the inverse function of the price function, and its derivative is the function of depth w.r.t. price.&lt;/p&gt;
&lt;p&gt;That concludes the relationship between market price/depth and base/quote function.&lt;/p&gt;
&lt;h1&gt;Mathematical Background - Solving&lt;/h1&gt;
&lt;p&gt;For a creator of AMM pool, they care the most about the initial price (price0) and initial depth (depth0). From mathematic perspective, they need to give an AMM function of the form &lt;code class=&quot;language-text&quot;&gt;quote = f(base)&lt;/code&gt;, so that there’s a coordinate satisfying &lt;code class=&quot;language-text&quot;&gt;price = price0&lt;/code&gt; and &lt;code class=&quot;language-text&quot;&gt;depth = depth0&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;In other words, they need to solve the following equation:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;Given depth0, price0,
f is the function describing the relationship between base and quote amount, quote = f(base). Find a f that satisfies:

* There&amp;#39;s base0, such that f&amp;#39;(base0) = price0
* (Inverse(f&amp;#39;))&amp;#39;(price0) = depth0

Additionally, it&amp;#39;s required that f &amp;gt; 0, f&amp;#39; &amp;lt; 0 and f&amp;#39;&amp;#39; &amp;gt; 0, that is, f is a convex downward and monotonically decreasing function defined in the first quadrant.&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Actually, as the above equations has too few constraints, there are infinite number of solutions. f could be a reciprocal function, a more general hyperbolic function, an exponential function, or a power function. However in the next section, we will see that if we specify a certain form of f and limit its coefficients, we may be able to determine a unique solution.&lt;/p&gt;
&lt;h3&gt;One of the solutions - when f is a translated reciprocal function&lt;/h3&gt;
&lt;p&gt;If f is a reciprocal function in form of:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;quote = f(base) = C / (base + BASE_DELTA) - QUOTE_DELTA &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Or equivalently, using multiple variables:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;vQuote = C / vBase
vQoute = quote + QUOTE_DELTA
vBase = base + BASE_DELTA&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;where &lt;code class=&quot;language-text&quot;&gt;C&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;BASE_DELTA&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;QUOTE_DELTA&lt;/code&gt; are positive constants.&lt;/p&gt;
&lt;p&gt;When f is in this form, the price and depth could be derived as:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;price = -f&amp;#39;(base) = C / (vBase**2) = vQuote / vBase
depth = vBase**2 / (2 * vQuote)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;According to the condition that at &lt;code class=&quot;language-text&quot;&gt;price0&lt;/code&gt;, the depth is &lt;code class=&quot;language-text&quot;&gt;depth0&lt;/code&gt;, it can be solved as:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;C = vBase0 * vQuote0 = 4 * price0**3 * depth0**2
vQuote0 = 2 * price0**2 * depth0 = quote0 + QUOTE_DELTA
vBase0 = 2 * price0 * depth0 = base0 + BASE_DELTA&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So finally, the AMM function &lt;code class=&quot;language-text&quot;&gt;quote = f(base)&lt;/code&gt; will be:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;quote = f(base) = C / (base + BASE_DELTA) - QUOTE_DELTA,&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;where &lt;code class=&quot;language-text&quot;&gt;C = 4 * price0**3 * depth0**2&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;BASE_DELTA&lt;/code&gt; and &lt;code class=&quot;language-text&quot;&gt;QUOTE_DELTA&lt;/code&gt; are random constants.&lt;/p&gt;
&lt;p&gt;To conclude, we demonstrated that if specifying f as an reciprocal function, an unique solution of f could be obtained from price and depth. Although f can actually be any types of functions, for simplicity and without the loss of generality, we will use reciprocal function as our AMM function in the rest of the post.&lt;/p&gt;
&lt;h1&gt;Formula definition of Differential AMM&lt;/h1&gt;
&lt;p&gt;Synthesizing all the derivations in the previous section, we can get the complete definition of Differential AMM:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;quote = f(base) = C / (base + BASE_DELTA) - QUOTE_DELTA&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Terminology:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Name&lt;/th&gt;
&lt;th&gt;Meaning&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;price0&lt;/td&gt;
&lt;td&gt;initial market price&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;depth0&lt;/td&gt;
&lt;td&gt;initial market depth&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;lowPrice&lt;/td&gt;
&lt;td&gt;the lowest automatic market-making price, minimum is 0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;highPrice&lt;/td&gt;
&lt;td&gt;the highest automatic market-making price, maximum is positive inifinite&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;quote0&lt;/td&gt;
&lt;td&gt;initial actual quote amount&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;base0&lt;/td&gt;
&lt;td&gt;initial actual base amount&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;QUOTE_DELTA&lt;/td&gt;
&lt;td&gt;virtual quote amount&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;BASE_DELTA&lt;/td&gt;
&lt;td&gt;virtual base amount&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;C&lt;/td&gt;
&lt;td&gt;constant product&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;vQoute0&lt;/td&gt;
&lt;td&gt;initial total quote amount, including actual and virtual&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;vBase0&lt;/td&gt;
&lt;td&gt;initial total base amount, including actual and virtual&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Relationships between the parameters:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;(1) C = 4 * price0**3 * depth0**2
(2) lowPrice = QUOTE_DELTA**2 / C
(3) highPrice = C / BASE_DELTA**2
(4) price0 = vQuote0 / vBase0
(5) depth0 = vBase**2 / (2 * vQuote)
(6) vQoute0 = 2 * price0**2 * depth0
(7) vBase0 = 2 * price0 * depth0
(8) vQoute0 = quote0 + QUOTE_DELTA
(9) vBase0 = base0 + BASE_DELTA&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note1: Among the above formulas, (4)(5) and (6)(7) are equivalent.&lt;/p&gt;
&lt;p&gt;Note2: With the same &lt;code class=&quot;language-text&quot;&gt;price0&lt;/code&gt; and &lt;code class=&quot;language-text&quot;&gt;depth0&lt;/code&gt;, the smaller &lt;code class=&quot;language-text&quot;&gt;QUOTE_DELTA&lt;/code&gt; and &lt;code class=&quot;language-text&quot;&gt;BASE_DELTA&lt;/code&gt; are, the larger &lt;code class=&quot;language-text&quot;&gt;base0&lt;/code&gt; and &lt;code class=&quot;language-text&quot;&gt;quote0&lt;/code&gt; are. That is, when providing the same market liquidity, a greater amount of fund will lead to a lower so-called “capital efficiency”, but a wider market-making price range (i.e., from &lt;code class=&quot;language-text&quot;&gt;lowPrice&lt;/code&gt; to &lt;code class=&quot;language-text&quot;&gt;highPrice&lt;/code&gt;). Extremely, when &lt;code class=&quot;language-text&quot;&gt;QUOTE_DELTA&lt;/code&gt; and &lt;code class=&quot;language-text&quot;&gt;BASE_DELTA&lt;/code&gt; are both 0, &lt;code class=&quot;language-text&quot;&gt;lowPrice&lt;/code&gt; will be 0 and &lt;code class=&quot;language-text&quot;&gt;highPrice&lt;/code&gt; will be inifinite. In this situation, DAMM degenerates into Constant Product AMM. We could adjust capital efficiency arbitrarily by adjusting &lt;code class=&quot;language-text&quot;&gt;lowPrice&lt;/code&gt; and &lt;code class=&quot;language-text&quot;&gt;highPrice&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;In reality, for the following 3 groups of parameters, (A) depth price, (B) lowPrice highPrice, (C) quote0 base0, given any two groups, the third group, as well as the complete market-making function could be derived.&lt;/p&gt;
&lt;p&gt;Here are the three scenarios corresponding to three initial conditions:&lt;/p&gt;
&lt;h3&gt;Given price and depth (A), and initial amounts (C)&lt;/h3&gt;
&lt;p&gt;That is, in the equations, given &lt;code class=&quot;language-text&quot;&gt;price0&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;depth0&lt;/code&gt;, and &lt;code class=&quot;language-text&quot;&gt;quote0&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;base0&lt;/code&gt;, we then want to calculate market-making price range and other parameters.&lt;/p&gt;
&lt;p&gt;For step-by-step solution please refer to: &lt;a href=&quot;https://github.com/fluidex/differential-amm/blob/673b2801c822bc5e75dc63f1def0204b8d57bb03/main.ts#L39&quot;&gt;https://github.com/fluidex/differential-amm/blob/673b2801c822bc5e75dc63f1def0204b8d57bb03/main.ts#L39&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Given price and depth (A), and market-making price range (B)&lt;/h3&gt;
&lt;p&gt;That is, in the equations, given &lt;code class=&quot;language-text&quot;&gt;price0&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;depth0&lt;/code&gt;, and &lt;code class=&quot;language-text&quot;&gt;lowPrice&lt;/code&gt; (could be 0), &lt;code class=&quot;language-text&quot;&gt;highPrice&lt;/code&gt; (could be inifinity), need to calculate initial amount and other parameters.&lt;/p&gt;
&lt;p&gt;For step-by-step solution please refer to: &lt;a href=&quot;https://github.com/fluidex/differential-amm/blob/673b2801c822bc5e75dc63f1def0204b8d57bb03/main.ts#L53&quot;&gt;https://github.com/fluidex/differential-amm/blob/673b2801c822bc5e75dc63f1def0204b8d57bb03/main.ts#L53&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Given market-making price range (B), and initial amounts (C)&lt;/h3&gt;
&lt;p&gt;This is the most complex scenario. Actually it is equivalent to solving a binary quadratic equation. By solving the equation we could get all other parameters.&lt;/p&gt;
&lt;p&gt;For step-by-step solution please refer to: &lt;a href=&quot;https://github.com/fluidex/differential-amm/blob/673b2801c822bc5e75dc63f1def0204b8d57bb03/main.ts#L72&quot;&gt;https://github.com/fluidex/differential-amm/blob/673b2801c822bc5e75dc63f1def0204b8d57bb03/main.ts#L72&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;From the above three scenarios, we could see that DAMM has great flexibility. On the one hand, different scenarios may have different requirements and different initial conditions. Under the above three initial conditions, we are still able to solve a correct DAMM strategy. On the other hand, &lt;strong&gt;we can abitrarily adjust capital efficiency through the price range or initial amount&lt;/strong&gt;.&lt;/p&gt;
&lt;h1&gt;Miscellaneous&lt;/h1&gt;
&lt;h2&gt;Converting AAM to orderbook&lt;/h2&gt;
&lt;p&gt;By approximating the AMM curve section by section, we can get a discretized orderbook. In our &lt;a href=&quot;https://github.com/fluidex/differential-amm/blob/673b2801c822bc5e75dc63f1def0204b8d57bb03/main.ts#L156&quot;&gt;reference implementation&lt;/a&gt;, we could specify price interval and the number of orders, and get order size and average price by calculating BASE&lt;em&gt;DELTA and QUOTE&lt;/em&gt;DELTA.&lt;/p&gt;
&lt;h2&gt;Mathematical equivalance&lt;/h2&gt;
&lt;p&gt;It’s easy to see that DAMM is mathematically equivalent to the market maker algorithm (x + a)(y + b) = k. The difference is that we interpret it in a micro perspective way, as well as possibilities to solve from different initial conditions.&lt;/p&gt;
&lt;div class=&quot;footnotes&quot;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&quot;fn-1&quot;&gt;
&lt;p&gt;Although Uniswap V3 also supports providing liquidity in a price range, liquidity providers are not allowed to configure the base-quote ratio, neither can Uniswap V3 support single-side market making.&lt;/p&gt;
&lt;a href=&quot;#fnref-1&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content:encoded></item><item><title><![CDATA[Differential AMM: 一种基于微观指标设计的灵活 AMM 算法]]></title><description><![CDATA[摘要： 本文提出了一种基于微观指标 (资金量、价格区间、深度等) 设计的 AMM 算法。
比起传统的常函数做市商（CFMM）算法（及它们的变种）来说，它能更直观地反应市场、更契合流动性提供者的做市需求。 AMM 策略通常使用宏观指标来定义，宏观指标是指描述总量的指标，包括 AMM…]]></description><link>https://www.fluidex.io/zh/blog/damm/</link><guid isPermaLink="false">https://www.fluidex.io/zh/blog/damm/</guid><pubDate>Wed, 19 May 2021 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;&lt;strong&gt;摘要：&lt;/strong&gt; 本文提出了一种基于微观指标 (资金量、价格区间&lt;sup id=&quot;fnref-1&quot;&gt;&lt;a href=&quot;#fn-1&quot; class=&quot;footnote-ref&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;、深度等) 设计的 AMM 算法。
比起传统的常函数做市商（CFMM）算法（及它们的变种）来说，它能更直观地反应市场、更契合流动性提供者的做市需求。&lt;/p&gt;
&lt;p&gt;AMM 策略通常使用宏观指标来定义，宏观指标是指描述总量的指标，包括 AMM 池中的交易币种数量(base amount)和计价币种数量(quote amount)等。例如，最常见的 AMM 做市算法——恒定乘积算法——要求 base 数量 和 quote 数量的乘积在每次交易前后相等。但是实际上对于每个具体交易者而言，微观指标对单次的交易行为更有意义。微观指标是指刻画变化，或者叫刻画边际效应的指标，如当前的买卖盘口价和盘口深度。盘口价格刻画了当前状态下做一笔小交易的平均成交价格，而盘口深度刻画了指定交易价格内最大的成交量。盘口深度可以通俗解释为，假设现在 ETH-USDT 价格为 3450，我希望以不超过 3451 的价格购买尽可能多的 ETH，我最多能买到多少 ETH？&lt;/p&gt;
&lt;p&gt;盘口价格和盘口深度也是 orderbook 视角下更直观的指标。我们希望能从这两个微观指标出发，更好地理解和设计 AMM 算法。&lt;/p&gt;
&lt;h1&gt;数学原理-宏观指标和微观指标的关系&lt;/h1&gt;
&lt;p&gt;本章节会给出价格和深度这两个指标，和 base/quote 量的关系。我们将会看到，价格和深度函数，都可以从 base/quote 函数经过若干次求导/反函数变换推导出来。&lt;/p&gt;
&lt;p&gt;假设交易池中 base 数量和 quote 数量满足如下关系:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;quote = f(base)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;则显然有 quote &gt; 0, base &gt; 0. f 单调递减，即 f’ &amp;#x3C; 0（因为交易中，一种 token 增多，另一种当然减少）&lt;/p&gt;
&lt;p&gt;按照定义，价格就是 f 的导数的绝对值（正负原因需要取相反数）。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;price = abs(f&amp;#39;(base)) = -f&amp;#39;(base)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;一般我们要求价格(即 -f’)单调递减，即 base 越少，价格越高。因此 f” &gt; 0。综上，合理的 f，必然是一个定义在第一象限的下凸的单调递减函数。&lt;/p&gt;
&lt;p&gt;相应的，盘口深度(depth)实际上是总 base 量对于价格的导数。 &lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;depth = f2&amp;#39;(price)
f2 = Inverse(f&amp;#39;) 

Inverse 表示反函数&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上式中，f2 是价格函数的反函数，它的导数就是深度对于价格的函数。&lt;/p&gt;
&lt;p&gt;以上就是 盘口价格/盘口深度 和 base/quote 函数的关系。&lt;/p&gt;
&lt;h1&gt;数学原理-求解&lt;/h1&gt;
&lt;p&gt;对于 AMM 交易池的创建者而言，他最关心的是初始的价格(price0)和深度(depth0)。数学上看，他需要给出一个形如 quote = f(base) 的 AMM 函数，使得这个函数存在一点能够同时满足价格为 price0 且深度为 depth0。  &lt;/p&gt;
&lt;p&gt;换言之，创建者需要解以下的式子：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;已知 depth0, price0。
f 是描述 base 和 quote 数量的函数 quote = f(base)，求 f ，使其能够满足：

存在 base0 使得 f&amp;#39;(base0) = price0
(Inverse(f&amp;#39;))&amp;#39;(price0) = depth0

此外要求 f &amp;gt; 0 且 f&amp;#39; &amp;lt; 0 且 f&amp;#39;&amp;#39; &amp;gt; 0，即 f 为第一象限的下凸的单减函数。&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面式子约束太少，实际上有无数组解。f 可以是倒数函数，f 可以是更一般的双曲函数，f 可以是指数函数，f 可以是幂函数。但是下一节我们会看到，如果我们指定某种具体的 f 形式并且控制可以改变的系数，则可能可以确定函数的唯一解。&lt;/p&gt;
&lt;h3&gt;一种解：f 为平移倒数函数时的解&lt;/h3&gt;
&lt;p&gt;如果 f 为倒数函数，形式如下&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;quote = f(base) = C / (base + BASE_DELTA) - QUOTE_DELTA 

或者等价地，用多个变量表示
vQuote = C / vBase
vQoute = quote + QUOTE_DELTA
vBase = base + BASE_DELTA
其中 C BASE_DELTA QUOTE_DELTA 为正的常数&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;f 为这种形式时，求导得到价格和深度为&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;price = -f&amp;#39;(base) = C / (vBase**2) = vQuote / vBase
depth = vBase**2 / (2 * vQuote)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;按照 price0 处深度为 depth0 的条件，可以解得：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;C = vBase0 * vQuote0 = 4 * price0**3 * depth0**2
vQuote0 = 2 * price0**2 * depth0 = quote0 + QUOTE_DELTA
vBase0 = 2 * price0 * depth0 = base0 + BASE_DELTA&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;则最终 AMM 函数 quote = f(base) 为&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;quote = f(base) = C / (base + BASE_DELTA) - QUOTE_DELTA,
其中 C = 4 * price0**3 * depth0**2, BASE_DELTA QUOTE_DELTA 为任意常数。&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;综上，我们展示了如果指定 f 为倒数函数，则可以通过 price 和 depth 得到唯一函数解。虽然 f 实际上可以是无数多种函数类型，但是简化起见，我们后文都将使用倒数函数来作为我们的最终 AMM 函数。&lt;/p&gt;
&lt;h1&gt;Differential AMM 的公式定义&lt;/h1&gt;
&lt;p&gt;将上一节中所有的推导汇集在一起，我们可以得到 Differential AMM 的完整定义：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;quote = f(base) = C / (base + BASE_DELTA) - QUOTE_DELTA&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;DAMM 所有相关参数含义：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;price0&lt;/td&gt;
&lt;td&gt;初始盘口价&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;depth0&lt;/td&gt;
&lt;td&gt;初始盘口深度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;lowPrice&lt;/td&gt;
&lt;td&gt;最低自动做市价，最低可以是0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;highPrice&lt;/td&gt;
&lt;td&gt;最高自动做市价，最高可以是正无穷&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;quote0&lt;/td&gt;
&lt;td&gt;初始真实 quote 资金量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;base0&lt;/td&gt;
&lt;td&gt;初始真实 base 资金量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;QUOTE_DELTA&lt;/td&gt;
&lt;td&gt;虚拟 quote 资金量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;BASE_DELTA&lt;/td&gt;
&lt;td&gt;虚拟 base 资金量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;C&lt;/td&gt;
&lt;td&gt;恒定乘积&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;vQoute0&lt;/td&gt;
&lt;td&gt;初始总体 quote 量，真实加虚拟&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;vBase0&lt;/td&gt;
&lt;td&gt;初始总体 base 量，真实加虚拟&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;相关参数关系：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;(1) C = 4 * price0**3 * depth0**2
(2) lowPrice = QUOTE_DELTA**2 / C
(3) highPrice = C / BASE_DELTA**2
(4) price0 = vQuote0 / vBase0
(5) depth0 = vBase**2 / (2 * vQuote)
(6) vQoute0 = 2 * price0**2 * depth0
(7) vBase0 = 2 * price0 * depth0
(8) vQoute0 = quote0 + QUOTE_DELTA
(9) vBase0 = base0 + BASE_DELTA&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意1: 值得指出的是，上述式子中，(4)(5) 和 (6)(7) 是等价的。&lt;/p&gt;
&lt;p&gt;注意2: 同等 price0 depth0 时，QUOTE_DELTA 和 BASE_DELTA 越小，base0 quote0 越大，即提供同样盘口流动性的资金量越大，所谓“资金效率”越低，但是做市的价格范围（lowPrice到highPrice）也越大。极端地，当 QUOTE_DELTA 和 BASE_DELTA 为 0 时，lowPrice 将为 0，highPrice 为无穷大，此时 DAMM 蜕化为普通恒定乘积 AMM。我们可以通过调节 lowPrice highPrice，任意地调节资金效率。&lt;/p&gt;
&lt;p&gt;实际使用中，我们对于以下三组六个参数 (1) depth price (2) lowPrice highPrice (3) quote0 base0，已知任意两组，都可以推导出第三组参数和完整的做市函数。&lt;/p&gt;
&lt;p&gt;下面三种不同初始条件对应的 DAMM 应用场景。&lt;/p&gt;
&lt;h3&gt;给定盘口价格深度，和初始做市资金量&lt;/h3&gt;
&lt;p&gt;即在方程组中，已知 price0 depth0, 和 quote0，base0，需要计算做市价格范围和其他所有剩余参数。&lt;/p&gt;
&lt;p&gt;具体求解见： &lt;a href=&quot;https://github.com/fluidex/differential-amm/blob/673b2801c822bc5e75dc63f1def0204b8d57bb03/main.ts#L39&quot;&gt;https://github.com/fluidex/differential-amm/blob/673b2801c822bc5e75dc63f1def0204b8d57bb03/main.ts#L39&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;给定盘口价格深度，和做市价格范围&lt;/h3&gt;
&lt;p&gt;即在方程组中，已知 price0 depth0, 和 lowPrice（可以为 0），highPrice（可以为  Infinity），需要计算出初始做市资金量和其他所有剩余参数。&lt;/p&gt;
&lt;p&gt;具体求解见：&lt;a href=&quot;https://github.com/fluidex/differential-amm/blob/673b2801c822bc5e75dc63f1def0204b8d57bb03/main.ts#L53&quot;&gt;https://github.com/fluidex/differential-amm/blob/673b2801c822bc5e75dc63f1def0204b8d57bb03/main.ts#L53&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;给定做市价格范围，和初始做市资金量&lt;/h3&gt;
&lt;p&gt;此种情况最为复杂。实际上等价于解一个二元二次方程。通过解这个方程我们也可以得到所有剩余参数。&lt;/p&gt;
&lt;p&gt;具体求解：&lt;a href=&quot;https://github.com/fluidex/differential-amm/blob/673b2801c822bc5e75dc63f1def0204b8d57bb03/main.ts#L72&quot;&gt;https://github.com/fluidex/differential-amm/blob/673b2801c822bc5e75dc63f1def0204b8d57bb03/main.ts#L72&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;从上面三种应用场景可以看到 DAMM 具有极大的灵活性。灵活性一方面体现在，不同的场景可能有不同的做市需求和不同的初始条件，在以上三种不同的初始条件情况下，我们都能求解出一个正确的 DAMM 策略。灵活性另一方面体现在，&lt;strong&gt;我们可以通过价格范围或初始资金量，任意调节做市资金效率&lt;/strong&gt;。&lt;/p&gt;
&lt;h1&gt;其他&lt;/h1&gt;
&lt;h2&gt;从 AMM 到 orderbook 的转化&lt;/h2&gt;
&lt;p&gt;将 AMM 曲线分段近似，就可以得到一份离散化 orderbook。在 &lt;a href=&quot;https://github.com/fluidex/differential-amm/blob/673b2801c822bc5e75dc63f1def0204b8d57bb03/main.ts#L156&quot;&gt;参考实现代码&lt;/a&gt; 中，我们可以指定价格 interval 和 order 数量，通过计算 base delta 和 quote delta，得到订单大小和平均价格。&lt;/p&gt;
&lt;h2&gt;数学等价性&lt;/h2&gt;
&lt;p&gt;容易看出 DAMM 在数学上等价于 (x + a)(y + b) = k 的做市算法。不同之处在于我们给了很多的微观诠释，也指出了多种不同的从初识条件求解的可能性。&lt;/p&gt;
&lt;div class=&quot;footnotes&quot;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&quot;fn-1&quot;&gt;
&lt;p&gt;虽然 Uniswap V3 也支持在一定价格区间内做市，但它们不支持在确定区间内调节配资比例，更无法支持单边做市。&lt;/p&gt;
&lt;a href=&quot;#fnref-1&quot; class=&quot;footnote-backref&quot;&gt;↩&lt;/a&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content:encoded></item><item><title><![CDATA[ZK-Rollup 开发经验分享 Part I]]></title><description><![CDATA[致谢：感谢 barryWhiteHat、Jordi Baylina、Koh Wei Jie…]]></description><link>https://www.fluidex.io/zh/blog/zkrollup-intro1/</link><guid isPermaLink="false">https://www.fluidex.io/zh/blog/zkrollup-intro1/</guid><pubDate>Wed, 12 May 2021 09:00:00 GMT</pubDate><content:encoded>&lt;p&gt;&lt;em&gt;致谢：感谢 barryWhiteHat、Jordi Baylina、Koh Wei Jie 给我们提供的宝贵意见！（名字按字母序排序）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;对读者的期待：需要有基础的编程知识和区块链知识，可以没有任何密码学背景。&lt;/p&gt;
&lt;p&gt;很多用户期待区块链能进一步扩容，提升性能，降低使用成本。本文将谈到的 ZK-Rollup 是 &lt;a href=&quot;https://ethereum.org/nl/developers/docs/layer-2-scaling/&quot;&gt;以太坊 Layer 2 扩容方案&lt;/a&gt; 中的一种，它精巧地使用零知识证明(ZK-SNARK)这种密码学技术来完成链上计算资源消耗的压缩，从而能够极大地(~10x-100x)提升 Ethereum 的性能。包括 Ethereum 创始人 Vitalik 在内的很多人 认为 ZK-Rollup 是长期来看最重要的 Layer 2 扩容方案。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In general, my own view is that in the short term, optimistic rollups are likely to win out for general-purpose EVM computation and ZK rollups are likely to win out for simple payments, exchange and other application-specific use cases, but in the medium to long term ZK rollups will win out in all use cases as ZK-SNARK technology improves. — Vitalik&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文会分享一些 ZK-Rollup 开发中的经验。撰写本文的动机在于，互联网有大量高质量的资料介绍 ZK-SNARK （零知识证明）理论本身，这些文章会介绍详细的密码学细节，另一些不太偏向技术的文章则会展望 ZK-Rollup 的作用和前景。较少见有文章会深入地介绍 ZK-Rollup 到底是怎么提升性能的？一个完整的 ZK-Rollup 系统是长什么样的？ZK-Rollup 系统中有什么少被人讨论但是重要的常识经验吗？&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/fluidex/&quot;&gt;FluiDex 团队&lt;/a&gt; 作为全世界少数几个在独立开发完整 ZK-Rollup 系统的团队，希望能够分享一些自己在开发 ZK-Rollup 系统中的经验，能够反哺业界的其他参与者。我们想分享一些重要但是很少被谈到的话题，比如 ZK-Rollup 系统的性能瓶颈在哪里，它的成本又是如何构成的等。&lt;/p&gt;
&lt;h2&gt;ZK-SNARK&amp;#x26; ZK-Rollup 概述&lt;/h2&gt;
&lt;p&gt;本文重点不会在于零知识证明（ZK-SNARK） 的理论本身，因为这个话题你可以在互联网上搜到足够多高质量的资料，在此不多重复。本章节会简要介绍：ZK-SNARK 能做什么？它何以能够成为 ZK-Rollup 的核心部分，和 “rollup” 一起协助以太坊提升性能？rollup 又是什么意思？&lt;/p&gt;
&lt;h3&gt;ZK-SNARK 本质是什么？&lt;/h3&gt;
&lt;p&gt;在区块链系统中，一般而言每个节点会做完全相同的计算，每个节点都会执行区块中每个交易，并且验证它自己的执行结果和其他节点的执行结果完全相同。换言之，每个链上交易，都会被区块链的每一个参与节点执行一遍，这是为什么区块链系统性能较低的一个重要原因。&lt;/p&gt;
&lt;p&gt;只有重新计算一遍才能验证交易吗？换言之，验证的计算量一定得等于计算吗？&lt;/p&gt;
&lt;p&gt;不是的，验证可以比计算容易。举个例子，对于数独游戏而言，解数独的复杂性和验证数独游戏解的复杂性是完全不同的。“把计算重做一遍”是最差的验证方式。如果读者有计算机科学的背景，你可以回忆计算复杂度中 P vs NP 的问题。&lt;/p&gt;
&lt;p&gt;所以，在区块链中，如果有一种技术，能够降低验证的代价，即使增加了计算的代价，也是值得的。因为计算只发生一次，而验证会发生在每个节点上。&lt;strong&gt;ZK-SNARK 的本质正是这样一种压缩验证计算量的技术&lt;/strong&gt;，通常 ZK-SNARK 能够使得验证交易的计算量比执行交易少几个数量级，准确地说，是把验证的复杂度从线性变成常数(或对数)。&lt;/p&gt;
&lt;p&gt;对于一段特定的程序，ZK-SNARK 首先对这段程序做预处理，一次预处理完成之后，对于每份输入(input)，都首先计算输入的执行结果，再花费较大的计算资源生成一份 proof ( proof 实际上是很多大数 )。任何验证者，可以通过这份 proof 和本次执行使用的 input，快速验证执行的结果是正确的。&lt;/p&gt;
&lt;p&gt;更加精细的伪代码描述：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// here is the the application code&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// it is usually called &apos;circuit code&apos;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;some_function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;inputs&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt;
   &lt;span class=&quot;token comment&quot;&gt;// no global vars allowed here&lt;/span&gt;
   outputs &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;some_calculation&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;inputs&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
   &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; outputs


&lt;span class=&quot;token comment&quot;&gt;// preprocessing only runs once for every &apos;some_function&apos;&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// we deliberately ignore &apos;setup&apos; here to make it easier for understanding&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// for a more precise and detailed description, you can have a look at the references at the end of this article&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; preprocess_result &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;zksnark_preprocess&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;some_function&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; verification_key &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; preprocess_result&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;verification_key&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; proving_key &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; preprocess_result&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;proving_key&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// for every &apos;inputs&apos;, generate &apos;proof&apos;. The following codes run off chain&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// we deliberately ignore &apos;witness&apos; here to make it easier for understanding&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// we will make more explanation on what consists of inputs/outputs of a realworld ZK-Rollup system in the following sections&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; outputs &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;some_function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;inputs&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// the &apos;prove&apos; will need a lot of computing resource to finish&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; proof &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;zksnark_prove&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;proving_key&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; input&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; output&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// verify the input/output is correct&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// The following codes usually run on chain&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; is_correct &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;zksnark_verify&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;verification_key&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; input&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; output&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; proof&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;is_correct &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;真实世界 Rollup 系统的设计&lt;/h3&gt;
&lt;p&gt;在一般 Rollup 系统的设计中，我们会维护一颗全局的 merkle tree。Rollup 系统中的所有状态（一般至少包括每个账户每种 token 的余额，账户的 nonce 等）都会成为这棵树中的一个叶子结点。&lt;/p&gt;
&lt;p&gt;zksnark 会在数学上保证，每次对于 merkle tree 的更新都满足“预定规则”。这些“预定规则”是由 ZK-Rollup 的开发者的代码决定的。例如，对于一个 ZK-Rollup 转账系统，开发者可以在代码中要求，1. 转账金额小于转账发起账户的余额 2. 转账发起账户签名有效且 nonce 正确 3. 转账发起账户减少的金额等于转账接收账户增加的金额 ，此外，根结点的hash会从新的叶子结点重新计算出来。&lt;/p&gt;
&lt;p&gt;为了保证最坏情况下的安全性（即 ZK-Rollup 的运营者在跑路之后，用户的资金能不受损失地提出来），一般要求用户能够重建整棵树(这叫 data availability) ，能够证明 “张三确实有 3 个 ETH 在这颗树中”（通过 merkle proof 等手段）。这要求系统处理的每一笔交易的数据都是完整公开的，存在区块链上。&lt;/p&gt;
&lt;p&gt;我们通常对于数百甚至数千笔交易，按照指定顺序在这颗 merkle tree 上执行完成后，使用 ZK-SNARK 证明执行的结果（即新 merkle tree 的 root）是正确的。这数百或数千是一个预先决定的配置，而不能被动态更改。这批交易会被统一地证明和验证，它们被称为一个 “L2 Block”。&lt;/p&gt;
&lt;p&gt;我们来使用伪代码解释，一个真实世界 ZK-Rollup 系统中的数据流形态：&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// the following code runs as smart contract&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// &apos;global_merkle_tree_root&apos; is the only state needed to be stored inside smart contract&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; global_merkle_tree_root &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; verification_key &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// set global_merkle_tree_root and verification_key&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;verify_txs&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;proof&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; txs&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; old_merkle_root&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; new_merkle_root&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;token function&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;old_merkle_root &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; global_merkle_tree_root&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;token comment&quot;&gt;// in fact we will hash of txs/old_merkle_root/new_merkle_root as a single input to &apos;zksnark_verify&apos; for performance. We will not discuss this detail here as it does not block understanding&lt;/span&gt;
   &lt;span class=&quot;token function&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;zksnark_verify&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;proof&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; txs&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; old_merkle_root&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; new_merkle_root&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
   global_merkle_tree_root &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; new_merkle_root&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到，合约自身除 merkle root 外，并不储存任何状态。每次状态更新都需要链下模块来准备完整的交易输入和 proof。熟悉 Stateless Ethereum 的读者会意识到 Stateless Ethereum 和 ZK-Rollup 这两者的本质是非常相似的。&lt;/p&gt;
&lt;!---
这里要不要解释下 witness / merkle proof 这些东西？
--&gt;
&lt;h2&gt;ZK-Rollup 系统架构&lt;/h2&gt;
&lt;p&gt;ZK-Rollup 系统至少需要以下几个组件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;链上智能合约：负责验证 Merkle tree 的每次状态更新都是有效的，维护正确的 merkle tree root；在 Rollup 系统完全停机时，能够保证用户可以直接调用合约提取自己应有的资产；协调 L1 和 L2，保证用户向合约的充值能被及时处理并被更新在 Merkle tree 中。&lt;/li&gt;
&lt;li&gt;Prover Cluster：对每个 L2 Block 做大量密码学计算获得 zksnark proof。通常需要一个大规模集群，会占用了系统中超过 99% 的计算资源。&lt;/li&gt;
&lt;li&gt;State Manager：维护完整的 merkle tree。对于每个 tx，更新 merkle tree 并且为 prover cluster 提供必要的数据（如 merkle proof）。&lt;/li&gt;
&lt;li&gt;其他业务模块：如 L2 浏览器；此外，不同的具体 Rollup 系统还会有自己专门的业务模块，如 FluiDex 会有一个&lt;a href=&quot;https://github.com/fluidex/dingir-exchange&quot;&gt;订单簿撮合引擎&lt;/a&gt;，从用户的委托订单生成匹配的交易，发送给 State Manager。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;ZK-Rollup 的 TPS 能力上限&lt;/h2&gt;
&lt;p&gt;一个 ZK-Rollup 系统的 TPS 能力上限被什么制约？&lt;/p&gt;
&lt;h3&gt;证明速度&lt;/h3&gt;
&lt;p&gt;证明是 ZK-Rollup 系统中最消耗计算资源的部分。刚刚接触 ZK-Rollup 的人常常会误认为证明速度限制了 TPS 的上限。实际上每个 L2 Block 的证明是可以完全并行的，使用几百台服务器来搭建证明集群是 common practice。zksnark 证明耗时长，会使得从 L2 向 L1 提现完成需要的时间更久，会给运营方造成更高的服务器成本，但不会限制 TPS。&lt;/p&gt;
&lt;h3&gt;数据上链和 ETH GAS 限制&lt;/h3&gt;
&lt;p&gt;这是一个真正限制 ZK-Rollup TPS 的因素。我们回顾刚才介绍的 ZK-Rollup 整体设计，可以看到为了安全性/data availability，每笔 layer 2 的交易都要有数据会上链。这部分数据会作为 CALLDATA 存入 ETH 的交易历史中，平均价格可以按照 16gas/byte (EIP-2028: &lt;a href=&quot;https://eips.ethereum.org/EIPS/eip-2028&quot;&gt;[1]&lt;/a&gt;, &lt;a href=&quot;https://blog.iden3.io/istanbul-zkrollup-ethereum-throughput-limits-analysis.html&quot;&gt;[2]&lt;/a&gt;) 来估计。对于一般的转账&amp;#x26;撮合等交易，每笔交易可以按照 40 bytes 来估计（&lt;a href=&quot;https://vitalik.ca/general/2021/01/05/rollup.html&quot;&gt;[1]&lt;/a&gt;, &lt;a href=&quot;https://github.com/Loopring/protocols/blob/master/packages/loopring_v3/DESIGN.md#data-availability&quot;&gt;[2]&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;每个 ETH 块大约需要 13s，最高允许 gas 为 12.5 Million。按照单次 Groth16/Plonk zksnark verify 成本为 0.3-0.5 Million gas 推算 (&lt;a href=&quot;https://github.com/matter-labs/awesome-zero-knowledge-proofs&quot;&gt;[1]&lt;/a&gt;, &lt;a href=&quot;https://medium.com/matter-labs/zksync-v1-1-reddit-edition-recursion-up-to-3-000-tps-subscriptions-and-more-fea668b5b0ff&quot;&gt;[2]&lt;/a&gt;, &lt;a href=&quot;https://blog.kyber.network/research-trade-offs-in-rollup-solutions-a1084d2b444&quot;&gt;[3]&lt;/a&gt;, &lt;a href=&quot;https://zksync.io/&quot;&gt;[4]&lt;/a&gt;, &lt;a href=&quot;https://ethresear.ch/t/on-chain-scaling-to-potentially-500-tx-sec-through-mass-tx-validation/3477&quot;&gt;[5]&lt;/a&gt;, &lt;a href=&quot;https://ethresear.ch/t/roll-up-roll-back-snark-side-chain-17000-tps/3675/12&quot;&gt;[6]&lt;/a&gt;)，单个 ETH block 内能容纳的 tx 数量上限为 12,000,000 / (40*16) ~= 20000。因此按照链上 gas 限制估算的 ZK-Rollup TPS 上限约为 1500-2000。这也是很多 Rollup 系统在白皮书中声称的性能上限。&lt;/p&gt;
&lt;h3&gt;Merkle Tree 全局状态的更新&lt;/h3&gt;
&lt;p&gt;这是一个很少被讨论但是至关重要的角度，&lt;strong&gt;真实 ZK-Rollup 系统的性能上限实际上更被这个模块限制，而不是上面讨论的证明速度和 gas 限制&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;容纳较多用户和资产对于 Merkle tree 的深度有一定要求。假设使用 binary dense account_balance merkle tree (如下图所示) ，我们打算容纳 1 Million 用户和 1000 种资产，则需要的 merkle tree 深度为 30。对于每笔交易，假设会导致 5-10 次 merkle proof 的验证，则总计约需要 200 次 hash。ZK-Rollup Merkle tree 中的 hash 出于 zksnark 证明性能考虑，不会使用 sha3 等普通 hash，而会使用 poseidon / rescue 等适用于 zksnark 的 hash 方式。按照 &lt;a href=&quot;https://github.com/fluidex/state_keeper/blob/a80c40015984886b68a295a810c64a682ba13135/src/types/merkle_tree.rs#L326&quot;&gt;FluiDex 团队的测试结果&lt;/a&gt;，单次 poseidon hash 按照 30us 计算（每个test的树深度为20，故每个hash操作是57ms / 100 / 20 ~= 30us），则从 Merkle tree 角度估算的 ZK-Rollup 系统性能上限为 1 / 0.00003 / 200 = 160 TPS。&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/54e1727768d29bc1b328dc1cc1dda2fc/94829/account-merkle-tree.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 85.44303797468356%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAACXBIWXMAAAsTAAALEwEAmpwYAAABiklEQVQ4y5WSV6rDQAxFZ/9rCok3EBLyk0ac3nvv1uMIZMZ5dopgGDNGV7fIyYeKoihxU8vlUmq1mtTrdalUKnK5XOJ/Tr4oA7vdbnI4HKTf70uz2ZThcCitVksGg4Hsdju5Xq/vAQHywWBG43g8lul0qu+r1UqB9/u9NBqNzwx9qYvFQmazmYLO53N9W6/Xst1uFTAMw/+APiu7z+eznE4nlQrg/X5P/H88HrGP7htmm81Ger2egnU6HZWZ1ePeJWqT8YiDZPzjRirAsPX7XBqYfbMWpVJJisWiMvOLlHmbTCaasvW4LJlMJrVyuSzValUZPp/PhA2EQyCwTTD0WSEHKSSGPEuy3W5rsqyOhYIlNsQw3KtvJAkQzaPRSN8IgzfACIedpADjGFiCoV800uQPg80rozSrYobIYNdgYJ6kDcsKMA7FPvANk7nxEXC/6fVkDXPmA55hfLfb1UCOx+PH5rRyMAKMnWIFaCQMpNtq/ARYKBQkn89LEASaJsUy53I5PSywJfpN/QENgim6OEM80QAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;account merkle tree&quot;
        title=&quot;account merkle tree&quot;
        src=&quot;/static/54e1727768d29bc1b328dc1cc1dda2fc/f058b/account-merkle-tree.png&quot;
        srcset=&quot;/static/54e1727768d29bc1b328dc1cc1dda2fc/c26ae/account-merkle-tree.png 158w,
/static/54e1727768d29bc1b328dc1cc1dda2fc/6bdcf/account-merkle-tree.png 315w,
/static/54e1727768d29bc1b328dc1cc1dda2fc/f058b/account-merkle-tree.png 630w,
/static/54e1727768d29bc1b328dc1cc1dda2fc/94829/account-merkle-tree.png 878w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;因此，必须实现 merkle tree 的 &lt;a href=&quot;https://github.com/fluidex/state_keeper/blob/a255043cbe7c899c6a8d9cc46b170a40f20623c9/src/types/merkle_tree.rs#L127&quot;&gt;并行更新&lt;/a&gt;， ZK-Rollup 的 TPS 才会突破 100-300 这个层次。和 zksnark proving 可以完美分布式多机多核并行不同，使用并行加速 merkle tree 的更新需要较精细的代码控制，而且非常难以实现多机分布式加速。这也是个工程上的挑战。&lt;/p&gt;
&lt;p&gt;上面推算的 100-300 TPS，接近不少实际运行中的 ZK-Rollup 系统的真实性能上限。&lt;/p&gt;
&lt;h2&gt;经济成本分析&lt;/h2&gt;
&lt;h3&gt;ZK-Rollup 一般需要几千个 CPU cores 做 proving&lt;/h3&gt;
&lt;p&gt;我仍然拿 FluiDex 的 &lt;a href=&quot;https://github.com/fluidex/awesome-plonk&quot;&gt;PLONK&lt;/a&gt; &lt;a href=&quot;https://github.com/fluidex/circuits&quot;&gt;电路&lt;/a&gt; 作为一个典型 ZK-Rollup 系统的例子。在我们最新的一次性能测试中，每个包含 100 个交易的 L2 Block 的单次电路证明需要在 24core 服务器上消耗约 20min。因此如果需要达到 100 TPS 的性能，需要大约 300 台 EC2 c5.12xlarge，这意味着每小时 500 USD 左右的成本。此时每个 Layer 2 tx 链下计算成本为 0.001 USD。不过目前我们做性能优化的投入还很少，预计未来有较多提升空间。&lt;/p&gt;
&lt;h3&gt;链上的 gas 成本比链下服务器成本至少高两个数量级&lt;/h3&gt;
&lt;p&gt;以上所说的链下计算成本，比起链上的 GAS 成本来说是九牛一毛。假设每个 Layer 2 tx 需要 40 bytes 的上链数据，ETH 价格 2000USD，GAS 价格 200GWEI，则每个 tx 需要的链上 GAS 成本约为 2.6 USD。这个成本远远高于链下 0.001 USD 的成本，但是又远远低于链上 Layer 1 复杂交易动则几十 USD 的 GAS 成本，这也是我们常常说 ZK-Rollup 能够带来至少两个数量级成本下降的数字来源。&lt;/p&gt;
&lt;h3&gt;云服务中 GPU 非常没有性价比&lt;/h3&gt;
&lt;p&gt;不少开发者会关心 GPU 带来的计算能力提升。在 zk snark prove 上，GPU 能带来的计算加速常在 3x-5x 这个层次。但是另一方面，由于虚拟化的不成熟，云服务商的 GPU 成本比起 CPU 成本会不成比例的昂贵，以至于出现了训练深度学习模型，&lt;a href=&quot;https://minimaxir.com/2017/07/cpu-or-gpu/&quot;&gt;CPU 比起 GPU 更便宜的奇观&lt;/a&gt;。因此，如果不是自建数据中心而是使用云服务，那么使用 GPU 来加速零知识电路证明是边际效用不高的选择。&lt;/p&gt;
&lt;p&gt;当然，以上所有的推算数据，会收系统代码效率和 ETH GAS 价格影响，但是预计可见未来内不太会出现量级偏差。&lt;/p&gt;
&lt;h2&gt;其他开发经验碎片&lt;/h2&gt;
&lt;h3&gt;ZK-SNARK 的逻辑描述为何被称为“电路”？&lt;/h3&gt;
&lt;p&gt;对于任何有软件开发经验的人来说，如下代码中，if 分支和 else 分支只会执行一个，而不是两个都执行后选择其中一个作为结果。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;binaryOp&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;op&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; arg1&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; arg2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;op &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;add&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; arg1 &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; arg2&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// assert(op == &apos;mul&apos;);&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; arg1 &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; arg2&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;“不同代码分支下，计算量不会同时发生”对于软件开发似乎是天经地义的，但是对于数字芯片电路的硬件设计却并非如此。在硬件时序电路代码开发中，一般所有“分支”（如果这还叫“分支”的话）的逻辑都会在时序触发时全部执行，开发者需要自己从不同“分支”的计算结果中，正确地选择和维护全局状态。&lt;/p&gt;
&lt;p&gt;在零知识证明系统中，代码逻辑会被转换成一些巨大（可能是几亿项）的多项式（称之为“算术化”），于是，问题就从“证明程序”转化为“证明多项式”。而多项式又会以门电路的方式被表达，以进行约束。这也是零知识证明电路被称之为“电路”的原因。因此零知识证明的代码具有和硬件电路相同的属性：所有分支的代码同时执行。这也就是“零知识证明电路”之所以被称为“电路”的原因。此外，和硬件电路类似，零知识证明电路中，没有递归和复杂循环，循环次数只能是常数（实际上最终这个循环会被作为语法糖展开，即 loop unrolling）。&lt;/p&gt;
&lt;p&gt;因此在开发零知识证明电路代码时，开发者要重新思考自己在编写软件代码时养成的认知和习惯。例如，优化软件时，我们可以专注于代码最常执行的路径，而对于代码少走的分支则可以不优先处理。但是在零知识电路开发中，每一个分支都是会被执行的，因此不常执行的分支也需要投入同样的精力来优化。&lt;/p&gt;
&lt;!---
这里有必要说吗？

在零知识证明电路中，最重要的元素是所谓“约束”，即我们要求一个多项式的值为0。在电路中常会有不同的模块，例如充值/转账等，他们各自有不同的约束条件，https://github.com/fluidex/circuits/blob/aaa488149c293b1e847c732e93f9841d5715d141/src/lib/binary_merkle_tree.circom#L76

--&gt;
&lt;h3&gt;对于 DSL 的看法&lt;/h3&gt;
&lt;p&gt;零知识证明电路的开发语言有不同的选择，既可以直接使用 C++/Rust 实现的底层计算库如 &lt;a href=&quot;https://github.com/HarryR/ethsnarks&quot;&gt;ethsnarks&lt;/a&gt; / &lt;a href=&quot;https://github.com/zkcrypto/bellman&quot;&gt;bellman&lt;/a&gt;，也可以使用一些 DSL 如 &lt;a href=&quot;https://github.com/Zokrates/ZoKrates&quot;&gt;ZoKrates&lt;/a&gt; / &lt;a href=&quot;https://github.com/iden3/circom&quot;&gt;Circom&lt;/a&gt; / &lt;a href=&quot;https://github.com/matter-labs/zinc&quot;&gt;Zinc&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;我们最终的选择是 circom。 Circom 提供了恰到好处的抽象，一方面提升了读写代码的效率，另一方面也没有扭曲底层的真实细节。相比起来，ethsnarks 和 bellman 编写电路代码开发效率略低一点，而且代码被团队内部或者外部审计时，很多代码上的“语法噪音”会不利于代码读者的注意力集中到真正的核心逻辑上。ZoKrates 和 Zinc 提供的抽象层次又太高，例如 ZoKrates 中的类似 python 的控制流语法，掩盖了底层电路的本质，也不利于做一些深入底层的优化（好比 C/Rust 中内嵌汇编）。&lt;/p&gt;
&lt;p&gt;如果用传统开发来类比，ethsnarks / bellman 更像是汇编，circom 是 C 语言，ZoKrates 是 Python。但是 ZoKrates 的工具链又没有真的成熟到 Python 解释器的程度，因此我们宁愿用 C 来作为唯一的开发语言，也不想自己同时维护 Python 代码和 CPython 解释器代码。&lt;/p&gt;
&lt;p&gt;不过，Circom 本质上还是一种 R1CS 的 DSL，但是 FluiDex 实际使用了 PLONK proof system，因此我们有可能未来会对 Circom 做较大的改动，来更好的支持 PLONK 的 custom gate / plookup / aggregation &amp;#x26; recursion 等特性。&lt;/p&gt;
&lt;h3&gt;处理充提的复杂性&lt;/h3&gt;
&lt;p&gt;处理充提要格外小心，因为这涉及了用户在以太坊主网上真实资金的改变。如果没处理好，用户/交易所则会蒙受真实资金的损失。&lt;/p&gt;
&lt;p&gt;要考虑的东西很多，比如区块可能发生回滚，不同的请求可能需要不同的处理优先级，合约的升级，等等。&lt;/p&gt;
&lt;p&gt;下面这个表列了一些需要考虑的情况（但不局限于以下这几条）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果一个 block 已经 commit 但是没有及时被 verify，那么应该将状态回滚到之前的状态。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果 rollup 一直不能 commit L2 blocks 或者提交对 L2 blocks 的 proof，又或者高优先的 (L1) 请求迟迟得不到处理，那么 rollup 应该被停机，并允许用户提走自己的资产。&lt;/p&gt;
&lt;!-- + 对于充值交易，如果充值一直得不到处理，应该允许用户在一段时间后提走自己的这笔充值。 --&gt;
&lt;/li&gt;
&lt;li&gt;路印中也描述了一种 &lt;a href=&quot;https://github.com/Loopring/protocols/blob/master/packages/loopring_v3/DESIGN.md#withdrawal-fee-griefing&quot;&gt;Withdrawal Fee Griefing Attack&lt;/a&gt; 以及应对的方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Hermez 中为了防止因为逻辑考虑不完善而导致资金被盗，设计了 &lt;em&gt;WithdrawalDelayer&lt;/em&gt;，辅以对资金异常情况的监控，以便进行对提现的管理。&lt;/p&gt;
&lt;h2&gt;更多阅读材料&lt;/h2&gt;
&lt;h3&gt;技术文章&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://vitalik.ca/general/2021/01/05/rollup.html&quot;&gt;vitalik blog on rollup&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://vitalik.ca/general/2021/01/26/snarks.html&quot;&gt;vitalik blog on ZK-SNARK&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.yuque.com/u428635/scg32w/edmn74&quot;&gt;深入浅出零知识证明之 ZK-SNARKs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.ethhub.io/ethereum-roadmap/ethereum-2.0/stateless-clients/&quot;&gt;Stateless Ethereum&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;项目代码&lt;/h3&gt;
&lt;p&gt;已经上线的 ZK-Rollup 项目：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/matter-labs/zksync&quot;&gt;zksync&lt;/a&gt;: 最完整的 ZK-Rollup 开源项目代码，涵盖了一个 ZK-Rollup 系统需要的每个组件。使用 PLONK 机制，电路代码使用 bellman，链下代码使用 Rust。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/hermeznetwork/&quot;&gt;hermez&lt;/a&gt;: 和 zksync 类似。使用 Groth16 机制，电路代码使用 circom，链下代码使用 Go。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Loopring/protocols/tree/master/packages/loopring_v3&quot;&gt;loopring&lt;/a&gt;: 仅开源了电路代码和合约代码，没有开源 State Manager 模块。使用 Groth16 机制，电路代码使用 ethsnark，链下代码不开源。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;开发中的 ZK-Rollup 项目：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/fluidex&quot;&gt;fluidex&lt;/a&gt;: 开源了电路代码，State Manager，交易所撮合引擎。 使用 PLONK 机制，电路代码使用 circom，链下代码使用 Rust。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用 zksnark 技术但是不属于 ZK-Rollup 的项目：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/appliedzkp/maci/&quot;&gt;MACI&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/tornadocash&quot;&gt;Tornado Cash&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;关于我们&lt;/h2&gt;
&lt;p&gt;我们是 &lt;a href=&quot;/zh/blog/fluidex-a-zkrollup-layer2-dex/&quot;&gt;“FluiDex: 基于 ZK-Rollup 的专业去中心化交易所”&lt;/a&gt; 的开发团队。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[ZK-Rollup development experience sharing, Part I]]></title><description><![CDATA[Acknowledgement: we would like to thank barryWhiteHat, Jordi Baylina, Koh Wei Jie (in alphabetical order) for their insightful feedbacks…]]></description><link>https://www.fluidex.io/en/blog/zkrollup-intro1/</link><guid isPermaLink="false">https://www.fluidex.io/en/blog/zkrollup-intro1/</guid><pubDate>Wed, 12 May 2021 09:00:00 GMT</pubDate><content:encoded>&lt;p&gt;&lt;em&gt;Acknowledgement: we would like to thank barryWhiteHat, Jordi Baylina, Koh Wei Jie (in alphabetical order) for their insightful feedbacks.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Prerequisites: basic programming and blockchain knowledge, no cryptography background needed.&lt;/p&gt;
&lt;p&gt;Currently, major expectations on blockchain technology are further scaling, higher performance and lower costs. In this post, we will dive into ZK-Rollup, which is one of the &lt;a href=&quot;https://ethereum.org/nl/developers/docs/layer-2-scaling/&quot;&gt;Ethereum layer 2 scaling solutions&lt;/a&gt;. It exquisitely applies a zero knowledge proof technique (known as ZK-SNARK) to reduce the on-chain costs, and thus, is able to improve Ethereum TPS considerably (~10x-100x). ZK-Rollup is considered as the most important Ethereum Layer 2 scaling solution in the long term by many people, including Vitalik, the founder of Ethereum.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In general, my own view is that in the short term, optimistic rollups are likely to win out for general-purpose EVM computation and ZK rollups are likely to win out for simple payments, exchange and other application-specific use cases, but in the medium to long term ZK rollups will win out in all use cases as ZK-SNARK technology improves. — Vitalik&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;In this series of posts, we will share our experience on developing a ZK-Rollup system. The motivation of these posts is that, currently there are many high quality resources introducing the cryptography behind ZK-SNARK, with a lot of math details. In the meantime, there are also many non-technical blogs looking into the impact and prospect of ZK-Rollup. Very few will dive into questions like, how does ZK-Rollup boost performance exactly? Or, how does a complete ZK-Rollup system look like? Or, is there any important but usually overlooked details in a ZK-Rollup system?&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/fluidex/&quot;&gt;FluiDex&lt;/a&gt;, as one of the very few teams that are independently developing a ZK-Rollup system from scratch, is happy to share some experience gained from ZK-Rollup system development. We hope this could benefit other developers in the field. We will talk about some important but rarely mentioned topics, like where the performance bottleneck is in a ZK-Rollup system, where does the economic cost lie, etc.&lt;/p&gt;
&lt;h2&gt;Overview of ZK-SNARK &amp;#x26; ZK-Rollup&lt;/h2&gt;
&lt;p&gt;Again, we won’t focus on the cryptographic details of ZK-SNARK proof, because as stated, there are enough high quality resources explaining it. In this chapter, we will briefly answer the following questions: What can ZK-SNARK do? Why does it become the core of ZK-Rollup, and help boost Ethereum performance along with “rollup”? What does “rollup” mean exactly?&lt;/p&gt;
&lt;h3&gt;The Nature of ZK-SNARK&lt;/h3&gt;
&lt;p&gt;Generally speaking, in a blockchain ecosystem, each node will execute the same computation for each transaction in the block, then verify that their results are the same as those of other nodes. In other words, for each transaction to be on chain, it will be executed by every node. That’s one major reason why blockchain have relatively low performance.&lt;/p&gt;
&lt;p&gt;However, is “computing again” the only way to verify a transaction? To put it differently: is it necessary that the cost of verifying is as much as the cost of computing?&lt;/p&gt;
&lt;p&gt;The answer is NO. Verifying could be cheaper than computing. Let’s take Sudoku for example. The complexity of solving a Sudoku is quite different from that of verifying a Sudoku solution. To “compute again” is the least efficient verification method. If you happen to have a computer science background, just consider the P vs NP problems in computational complexity theory.&lt;/p&gt;
&lt;p&gt;Therefore, in blockchain, it’s worthwhile to have a technical solution that can lower the verification cost, even by increasing the computation cost. The reason is that, for each transaction, computation will only happen once, while verification will happen on every node. &lt;strong&gt;ZK-SNARK by nature is such a technique that significantly lowers the verification cost.&lt;/strong&gt; Generally, ZK-SNARK can make the verification cost several orders of magnitude less than the computational cost. To be precise, reducing the verification complexity from linear to constant (or logarithmic), that is what “succinctness”, the “S” in “SNARK”, stands for.&lt;/p&gt;
&lt;p&gt;Let’s look at how ZK-SNARK works.&lt;/p&gt;
&lt;p&gt;For a particular program, it will first be preprocessed. After the one-off preprocessing, for each input, a prover will need to compute the result corresponding to the input, as well as generate a “proof” (usually in form of big integers) with relatively larger costs. Any verifier could use this “proof” and input to quickly verify the correctness of the result without actually running the program.&lt;/p&gt;
&lt;p&gt;A more detailed description in pseudo code:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// here is the the application code&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// it is usually called &apos;circuit code&apos;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;some_function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;inputs&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt;
   &lt;span class=&quot;token comment&quot;&gt;// no global vars allowed here&lt;/span&gt;
   outputs &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;some_calculation&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;inputs&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
   &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; outputs


&lt;span class=&quot;token comment&quot;&gt;// preprocessing only runs once for every &apos;some_function&apos;&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// we deliberately ignore &apos;setup&apos; here to make it easier for understanding&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// for a more precise and detailed description, you can have a look at the references at the end of this article&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; preprocess_result &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;zksnark_preprocess&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;some_function&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; verification_key &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; preprocess_result&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;verification_key&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; proving_key &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; preprocess_result&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;proving_key&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// for every &apos;inputs&apos;, generate &apos;proof&apos;. The following codes run off chain&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// we deliberately ignore &apos;witness&apos; here to make it easier for understanding&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// we will make more explanation on what consists of inputs/outputs of a realworld ZK-Rollup system in the following sections&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; outputs &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;some_function&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;inputs&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// the &apos;prove&apos; will need a lot of computing resource to finish&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; proof &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;zksnark_prove&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;proving_key&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; input&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; output&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;token comment&quot;&gt;// verify the input/output is correct&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// The following codes usually run on chain&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; is_correct &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;zksnark_verify&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;verification_key&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; input&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; output&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; proof&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token function&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;is_correct &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Real-world Design of a Rollup System&lt;/h3&gt;
&lt;p&gt;In a normal Rollup system, we will maintain a global merkle tree. All states in the Rollup system (including the balance of each token of the account, nonce of the account, etc.) will become a leaf node on the tree.&lt;/p&gt;
&lt;p&gt;ZK-SNARK will guarantee mathematically that every update to the merkle tree satisfies some “predetermined rules”. Those rules are determined by the ZK-Rollup developers’ settings. For example, for a ZK-Rollup transfer system, the developers could demand that:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Transfer amount is less than the balance of the sender account;&lt;/li&gt;
&lt;li&gt;The signature of the sender account is valid, and nonce is correct;&lt;/li&gt;
&lt;li&gt;The amount reduced in the sender account equals the amount increased in the receiver account.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Additionally, the hash of the merkle root will be computed from the new leaf.&lt;/p&gt;
&lt;p&gt;To guarantee security in the worst case (that is, even if the operators of the Rollup system run off, users can still withdraw their assets in one piece), the system should make sure users are able to rebuild the tree from scratch (known as “data availability”), and are able to make assertions  like “Alice actually has 3 ETH in this tree” by merkle proof. To achieve this, the system should make the data of each transaction public, and stored on chain.&lt;/p&gt;
&lt;p&gt;For a batch of hundreds or thousands of transactions, after we executed them in a particular order and updated the merkle tree, we will use ZK-SNARK to prove the correctness of the result (i.e., the new root of the merkle tree). Note that the number of transactions here is determined by a predefined config, which is fixed during runtime. This batch of transactions will be proved and verified together, known as a “L2 Block”.&lt;/p&gt;
&lt;p&gt;Again, let’s use pseudo code to demonstrate the data flow in a real-world ZK-Rollup system:&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// the following code runs as smart contract&lt;/span&gt;
&lt;span class=&quot;token comment&quot;&gt;// &apos;global_merkle_tree_root&apos; is the only state needed to be stored inside smart contract&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; global_merkle_tree_root &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; verification_key &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token comment&quot;&gt;// set global_merkle_tree_root and verification_key&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;verify_txs&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;proof&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; txs&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; old_merkle_root&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; new_merkle_root&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;token function&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;old_merkle_root &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; global_merkle_tree_root&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;token comment&quot;&gt;// in fact we will hash of txs/old_merkle_root/new_merkle_root as a single input to &apos;zksnark_verify&apos; for performance. We will not discuss this detail here as it does not block understanding&lt;/span&gt;
   &lt;span class=&quot;token function&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;zksnark_verify&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;proof&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; txs&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; old_merkle_root&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; new_merkle_root&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
   global_merkle_tree_root &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; new_merkle_root&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We can see that apart from the merkle root, the contract won’t store any states. For every state update, it needs the off-chain module to prepare the complete transaction input and proof. For those who are familiar with Stateless Ethereum, ZK-Rollup is actually very similar to Stateless Ethereum in this way.&lt;/p&gt;
&lt;h2&gt;System Architecture of ZK-Rollup&lt;/h2&gt;
&lt;p&gt;One ZK-Rollup system needs at least the following modules:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Smart Contract on Chain:&lt;/li&gt;
&lt;li&gt;To verify the validity of each merkle tree update, and maintain the correct merkle tree root;&lt;/li&gt;
&lt;li&gt;In a situation where Rollup system is down, to make sure users are able to withdraw their rightful assets by directly calling the contract;&lt;/li&gt;
&lt;li&gt;To coordinate between L1 and L2, ensuring users’ deposits can be processed in time and updated into the merkle tree.&lt;/li&gt;
&lt;li&gt;Prover Cluster: To do immense cryptographic calculations to generate ZK-SNARK proof for each L2 Block. Usually a large-scale cluster is required, which consumes more than 99% of the computing resources in the system.&lt;/li&gt;
&lt;li&gt;State Manager: To maintain the complete merkle tree. For each transaction, it updates the merkle tree and provides necessary data for Prover Cluster (e.g., merkle proof).&lt;/li&gt;
&lt;li&gt;Other Business Modules: like a L2 browser. Besides, each Rollup system has their own specialized business modules. For example, FluiDex has a &lt;a href=&quot;https://github.com/fluidex/dingir-exchange&quot;&gt;order matching engine&lt;/a&gt;, which generates matched transactions from users’ orders, then sends them to the State Manager.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;TPS limit of ZK-Rollup&lt;/h2&gt;
&lt;p&gt;What is the main constraint on TPS of a ZK-Rollup system?&lt;/p&gt;
&lt;h3&gt;Speed of proving&lt;/h3&gt;
&lt;p&gt;Proving is the most resource consuming part of a ZK-Rollup system. Those who are new to ZK-Rollup usually mistakenly believe that speed of proving is the main constraint on TPS. Actually, as the proving of each L2 Block can be done completely in parallel, using a prover cluster with size of hundreds is a common practice. Therefore, although ZK-SNARK proofs do take long, it will mostly lead to a longer latency of withdrawing from L2 to L1, as well as a higher server cost for operators, but not a limitation on TPS.&lt;/p&gt;
&lt;h3&gt;Recording data on-chain and ETH GAS limitations&lt;/h3&gt;
&lt;p&gt;Well this is a real constraint on TPS. Let’s look back at the overall ZK-Rollup design. To ensure security/data availability, each layer-2 transaction should be recorded on chain. This part of data will be recorded in ETH transaction history as CALLDATA, with an average cost of 16 gas/byte (EIP-2028: &lt;a href=&quot;https://eips.ethereum.org/EIPS/eip-2028&quot;&gt;[1]&lt;/a&gt;, &lt;a href=&quot;https://blog.iden3.io/istanbul-zkrollup-ethereum-throughput-limits-analysis.html&quot;&gt;[2]&lt;/a&gt;). For a normal transfer/matched order, each transaction is estimated to be 40 bytes (&lt;a href=&quot;https://vitalik.ca/general/2021/01/05/rollup.html&quot;&gt;[1]&lt;/a&gt;, &lt;a href=&quot;https://github.com/Loopring/protocols/blob/master/packages/loopring_v3/DESIGN.md#data-availability&quot;&gt;[2]&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;Let’s try estimating the TPS limit by gas limitations.&lt;/p&gt;
&lt;p&gt;It takes ~13s for each ETH block to be mined, with maximum gas of 12.5 Million. Suppose a Groth16/Plonk ZK-SNARK verification costs 0.3-0.5 Million gas (&lt;a href=&quot;https://github.com/matter-labs/awesome-zero-knowledge-proofs&quot;&gt;[1]&lt;/a&gt;, &lt;a href=&quot;https://medium.com/matter-labs/zksync-v1-1-reddit-edition-recursion-up-to-3-000-tps-subscriptions-and-more-fea668b5b0ff&quot;&gt;[2]&lt;/a&gt;, &lt;a href=&quot;https://blog.kyber.network/research-trade-offs-in-rollup-solutions-a1084d2b444&quot;&gt;[3]&lt;/a&gt;, &lt;a href=&quot;https://zksync.io/&quot;&gt;[4]&lt;/a&gt;, &lt;a href=&quot;https://ethresear.ch/t/on-chain-scaling-to-potentially-500-tx-sec-through-mass-tx-validation/3477&quot;&gt;[5]&lt;/a&gt;, &lt;a href=&quot;https://ethresear.ch/t/roll-up-roll-back-snark-side-chain-17000-tps/3675/12&quot;&gt;[6]&lt;/a&gt;), then each ETH block could contain at most 12,000,000 / (40*16) ~= 20,000 transactions. So in this way, the TPS limit of ZK-Rollup would be 1500-2000. This is also the performance upper-bound claimed by many Rollup systems in whitepapers.&lt;/p&gt;
&lt;h3&gt;Global state update on Merkle Tree&lt;/h3&gt;
&lt;p&gt;This is a rarely discussed but crucial perspective. &lt;strong&gt;The TPS of a real-world ZK-Rollup system is actually more limited by this module, rather than proving speed or gas limitations discussed above&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;To support a large number of users and assets, we need the Merkle Tree to have a certain depth. Assuming we are using a binary dense account_balance merkle tree as follows, and we intend to support 1 Million users and 1000 types of assets, then the depth of the merkle tree is required to be 30. Suppose each transaction will cause 5-10 times of verifications on the merkle proofs, then there’ll be ~200 hash calculations in total.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; &quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/54e1727768d29bc1b328dc1cc1dda2fc/94829/account-merkle-tree.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 85.44303797468356%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAACXBIWXMAAAsTAAALEwEAmpwYAAABiklEQVQ4y5WSV6rDQAxFZ/9rCok3EBLyk0ac3nvv1uMIZMZ5dopgGDNGV7fIyYeKoihxU8vlUmq1mtTrdalUKnK5XOJ/Tr4oA7vdbnI4HKTf70uz2ZThcCitVksGg4Hsdju5Xq/vAQHywWBG43g8lul0qu+r1UqB9/u9NBqNzwx9qYvFQmazmYLO53N9W6/Xst1uFTAMw/+APiu7z+eznE4nlQrg/X5P/H88HrGP7htmm81Ger2egnU6HZWZ1ePeJWqT8YiDZPzjRirAsPX7XBqYfbMWpVJJisWiMvOLlHmbTCaasvW4LJlMJrVyuSzValUZPp/PhA2EQyCwTTD0WSEHKSSGPEuy3W5rsqyOhYIlNsQw3KtvJAkQzaPRSN8IgzfACIedpADjGFiCoV800uQPg80rozSrYobIYNdgYJ6kDcsKMA7FPvANk7nxEXC/6fVkDXPmA55hfLfb1UCOx+PH5rRyMAKMnWIFaCQMpNtq/ARYKBQkn89LEASaJsUy53I5PSywJfpN/QENgim6OEM80QAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;account merkle tree&quot;
        title=&quot;account merkle tree&quot;
        src=&quot;/static/54e1727768d29bc1b328dc1cc1dda2fc/f058b/account-merkle-tree.png&quot;
        srcset=&quot;/static/54e1727768d29bc1b328dc1cc1dda2fc/c26ae/account-merkle-tree.png 158w,
/static/54e1727768d29bc1b328dc1cc1dda2fc/6bdcf/account-merkle-tree.png 315w,
/static/54e1727768d29bc1b328dc1cc1dda2fc/f058b/account-merkle-tree.png 630w,
/static/54e1727768d29bc1b328dc1cc1dda2fc/94829/account-merkle-tree.png 878w&quot;
        sizes=&quot;(max-width: 630px) 100vw, 630px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;!-- 
_(In a transfer-oriented zkRollup, You could indeed combine account leaf and token leaf to reduce the merkle tree depth. However, for building a DEX a account_balance tree might still be more preferable, and since we are focusing on discussing the performance on updating the merkle tree, without the loss of generality, it&apos;s fine to discuss the model as account_balance tree here.)_
 --&gt;
&lt;p&gt;For performance considerations, we won’t use normal hash like SHA3 in a ZK-Rollup merkle tree. Instead, we’ll use a more ZK-SNARK compatible one like poseidon or rescue. According to &lt;a href=&quot;https://github.com/fluidex/state_keeper/blob/a80c40015984886b68a295a810c64a682ba13135/src/types/merkle_tree.rs#L326&quot;&gt;test results from FluiDex&lt;/a&gt;, each poseidon hash takes about 30us (tree depth of each test is 20, thus, each hash would be 57ms / 100 / 20 ~= 30us). So estimating from merkle tree perspective, the limit of a ZK-Rollup system would be 1 / 0.00003 / 200 = 160 TPS.&lt;/p&gt;
&lt;p&gt;Therefore, &lt;a href=&quot;https://github.com/fluidex/state_keeper/blob/a255043cbe7c899c6a8d9cc46b170a40f20623c9/src/types/merkle_tree.rs#L127&quot;&gt;parallel updating&lt;/a&gt; on the merkle tree is essential to break through the 100-300 TPS level. Unlike computing ZK-SNARK proofs, which could be parallelized completely, to parallelize merkle tree updates requires more discretion, and is very hard to apply distributed computing on it. This is also a technical challenge.&lt;/p&gt;
&lt;p&gt;The 100-300 TPS calculated above is close to many real-world ZK-Rollup system’s actual performance upper-bound.&lt;/p&gt;
&lt;h2&gt;Economic Cost Analysis&lt;/h2&gt;
&lt;h3&gt;ZK-Rollup normally needs thousands of CPU cores for proving&lt;/h3&gt;
&lt;p&gt;Let’s still take &lt;a href=&quot;https://github.com/fluidex/awesome-plonk&quot;&gt;PLONK&lt;/a&gt; &lt;a href=&quot;https://github.com/fluidex/circuits&quot;&gt;circuits&lt;/a&gt; used by FluiDex as a typical ZK-Rollup case. In our latest test, for each L2 Block with 100 transactions, it takes ~20min to run a proof on a 24 core server. To reach 100 TPS performance, we will need ~300 EC2 c5.12xlarge instances, which costs ~500 USD/h. This means each Layer 2 transaction will cost 0.001 USD in off-chain calculations. Note that we haven’t invested a lot on performance optimization yet, we expect there’ll be a lot to improve here in the future.&lt;/p&gt;
&lt;h3&gt;On-chain gas cost much higher than off-chain server cost&lt;/h3&gt;
&lt;p&gt;The cost of off-chain calculations mentioned above is actually a drop in the bucket compared to the on-chain GAS cost. Assuming each Layer 2 transaction needs 40 bytes of on-chain data, ETH is ~2000 USD, GAS price is 200 Gwei, then the cost of each transaction on-chain is ~2.6USD. This is much higher than the 0.001 USD off-chain. However, this is also much lower than a complex Layer 1 transaction, where GAS cost is usually at least tens of USD. That’s why we often say ZK-Rollup could bring at least two orders of magnitude cost saving.&lt;/p&gt;
&lt;h3&gt;Low cost-efficiency Cloud GPU services&lt;/h3&gt;
&lt;p&gt;Many developers might wonder what GPU could bring to computing power. In ZK-SNARK proving, GPUs could accelerate computing by ~3x-5x. But on the other hand, due to immaturity of virtualization, GPU from cloud services are disproportionately expensive compared to the cost of CPU. Such that there are even cases where &lt;a href=&quot;https://minimaxir.com/2017/07/cpu-or-gpu/&quot;&gt;CPU is cheaper than GPU&lt;/a&gt; in deep learning model training. Therefore, if you are not building your own data center but using cloud services, using GPU for ZK proofs would be a low marginal utility choice.&lt;/p&gt;
&lt;p&gt;Of course, all the above analysis data will be affected by system efficiency and ETH GAS price, but unlikely to deviate in orders of magnitude in a foreseeable future.&lt;/p&gt;
&lt;h2&gt;Miscellaneous development experience&lt;/h2&gt;
&lt;h4&gt;Why are ZK-SNARK logic descriptions called “circuits”?&lt;/h4&gt;
&lt;p&gt;For anyone with software engineer experience, in the following code, only one of the if- branch and else- branch will be executed, rather than both executed and only one chosen.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;js&quot;&gt;&lt;pre class=&quot;language-js&quot;&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;binaryOp&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token parameter&quot;&gt;op&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; arg1&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; arg2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;op &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;add&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; arg1 &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; arg2&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token comment&quot;&gt;// assert(op == &apos;mul&apos;);&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; arg1 &lt;span class=&quot;token operator&quot;&gt;*&lt;/span&gt; arg2&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Such concept that “only one conditional branch will be executed” seems natural for software development, but it’s not the case for the design of hardware chip circuits. In development of sequential logic circuits in hardware, logics of all “branches” (if still called “branch”) will be executed at the time the sequence is triggered. The developer needs to choose and maintain correct global states from different “branches”.&lt;/p&gt;
&lt;p&gt;In a ZKP system, program logic will eventually be converted into some immense polynomials (probably with hundreds of millions of terms), which is called arithmetization, such that proving of the program will be converted to proving of the polynomials. The polynomials are then constrained in the form of gate circuit. That’s also one of the reason why we call ZKP programs as circuits. Thus, the code has the same property as hardware circuits: code from all branches will be executed together. That’s why ZK proof code is called “circuits”. In addition, similar to hardware circuits, there are no recursion and complex loops in the ZK proof circuits, and the number of loops can only be constant (actually, loops will be unrolled as syntactic sugars, i.e., loop unrolling).&lt;/p&gt;
&lt;p&gt;Therefore, when developing ZK proof circuits, developers need to reconsider their habits from software development. For example, when optimizing softwares, we could focus on the most frequently executed branch, and deprioritize the non-frequent ones. But in ZK proof circuits, as all branches will be executed, the non-frequent branches need to be considered as well.&lt;/p&gt;
&lt;h3&gt;Some thoughts on DSL&lt;/h3&gt;
&lt;p&gt;There are several choices for ZK proof circuit development, such as low-level computing libraries like &lt;a href=&quot;https://github.com/HarryR/ethsnarks&quot;&gt;ethsnarks&lt;/a&gt; / &lt;a href=&quot;https://github.com/zkcrypto/bellman&quot;&gt;bellman&lt;/a&gt;, or DSL like &lt;a href=&quot;https://github.com/Zokrates/ZoKrates&quot;&gt;ZoKrates&lt;/a&gt; / &lt;a href=&quot;https://github.com/iden3/circom&quot;&gt;Circom&lt;/a&gt; / &lt;a href=&quot;https://github.com/matter-labs/zinc&quot;&gt;Zinc&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;We chose Circom, which provides a just right level of abstraction. On the one hand, it improves the efficiency of reading/writing code, on the other hand, it doesn’t distort the details of the underlying circuits.&lt;/p&gt;
&lt;p&gt;In comparison, developing with ethsnarks and bellman is of lower efficiency. Also, when the code is being reviewed, no matter internally or externally, too much “syntactic noise” prevents the reviewer from focusing on the core logic. Additionally, ZoKrates and Zinc provide a too high level of abstraction. For example, python-style control flow syntax in ZoKrates conceals the underlying circuits, and is not conducive to lower level optimizations (such as inline assembly of C/Rust).&lt;/p&gt;
&lt;p&gt;As an analogy,  ethsnarks / bellman is like assembly language in traditional development, while cirom is like C, and ZoKrates is like Python. However, ZoKrates toolchain is not as mature as Python interpreter. That’s why we’d rather use “C” (cirom in this case) as the our development language, instead of maintaining both “Python” (ZoKrates in this case) code and “CPython interpreter” (ZoKrates interpreter in this case) code.&lt;/p&gt;
&lt;p&gt;However, Circom is essentially still a R1CS DSL. FluiDex actually uses PLONK proof system. We probably would make major changes on Circom to better utilize PLONK, including supports for custom gate, plookup, aggregation &amp;#x26; recursion, etc.&lt;/p&gt;
&lt;h3&gt;It’s not easy to handle deposit / withdrawal&lt;/h3&gt;
&lt;p&gt;It’s not easy to handle deposit / withdrawal correctly at all: for example, we need to consider block reverting, operations with different priorities, contract migrations, and so on. &lt;/p&gt;
&lt;p&gt;And we should always deal with deposit &amp;#x26; withdrawal carefully, because it affects users’ assets on Ethereum layer 1 for real.&lt;/p&gt;
&lt;p&gt;The following is a non-exhaustive list of things we need to take into consideration:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If a committed L2 block is not verified in time, state should be reverted.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;If the rollup fails to commit L2 blocks or submit proofs in time, or a priority operation is not processed for a long time, the rollup needs to be suspended and we should provide a way for user to withdraw funds.&lt;/p&gt;
&lt;!-- + For a deposit, user should be able to withdraw the deposited amount if the deposit is not processed after a given time. --&gt;
&lt;/li&gt;
&lt;li&gt;Loopring also describes an interesting &lt;a href=&quot;https://github.com/Loopring/protocols/blob/master/packages/loopring_v3/DESIGN.md#withdrawal-fee-griefing&quot;&gt;Withdrawal Fee Griefing Attack&lt;/a&gt;, and an solution to it.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Hermez uses &lt;em&gt;WithdrawalDelayer&lt;/em&gt; to manage withdrawals, to leave time for handling unexpected situations.&lt;/p&gt;
&lt;h2&gt;Further Readings&lt;/h2&gt;
&lt;h3&gt;Techinical Blogs&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://vitalik.ca/general/2021/01/05/rollup.html&quot;&gt;vitalik blog on rollup&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://vitalik.ca/general/2021/01/26/snarks.html&quot;&gt;vitalik blog on ZK-SNARK&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.ethhub.io/ethereum-roadmap/ethereum-2.0/stateless-clients/&quot;&gt;Stateless Ethereum&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Projects&lt;/h3&gt;
&lt;p&gt;ZK-Rollup projects launched:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/matter-labs/zksync&quot;&gt;zksync&lt;/a&gt;: the most complete open source code of ZK-Rollup, containing all modules for a ZK-Rollup system. It uses PLONK protocol, bellman for circuits, and Rust for off-chain code.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/hermeznetwork/&quot;&gt;hermez&lt;/a&gt;: similar to zksync. It uses Groth16 protocol, Circom for circuits, and Go for off-chain code.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Loopring/protocols/tree/master/packages/loopring_v3&quot;&gt;loopring&lt;/a&gt;: only has circuit code and contract in open source. It uses Groth16 protocol, ethsnark for circuits. Off-chain code is not open sourced yet.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ZK-Rollup projects under developing:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/fluidex&quot;&gt;fluidex&lt;/a&gt;: circuits, state manager, and matching engine in open sourced. It uses PLONK protocol, circom for circuits, and Rust for off-chain code.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Non ZK-Rollup projects that use ZK-SNARK:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/appliedzkp/maci/&quot;&gt;MACI&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/tornadocash&quot;&gt;Tornado Cash&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;About Us&lt;/h2&gt;
&lt;p&gt;We are the development team of &lt;a href=&quot;/en/blog/fluidex-a-zkrollup-layer2-dex/&quot;&gt;FluiDex: A Layer 2 ZK-Rollup DEX on Ethereum&lt;/a&gt;.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[The inconveniences in developing Cryptography using WASM, and the motivation of snarkit]]></title><description><![CDATA[More and more projects start to look into including WebAssembly (WASM) into their tech stacks, because there is not much interpretation…]]></description><link>https://www.fluidex.io/en/blog/the-motivation-of-snarkit/</link><guid isPermaLink="false">https://www.fluidex.io/en/blog/the-motivation-of-snarkit/</guid><pubDate>Sat, 17 Apr 2021 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;More and more projects start to look into including WebAssembly (WASM) into their tech stacks, because there is not much interpretation between WASM instructions and CPU instructions, so that even running WASM codes in a browser we can still achieve similar performance to running native CPU instructions. This could mean huge for supporting multiple platforms while remaining efficient. Nevertheless, we can compile C/C++/Java/Rust/GoLang, and etc., into WASM, and therefore reduce the learning curve.&lt;/p&gt;
&lt;p&gt;But this is just an ideal case. In fact, when it comes to Cryptography, there are some more factors needed to be taken into considerations. &lt;/p&gt;
&lt;p&gt;In modern CPUs, there are many optimizations for Cryptography, but they cannot be utilized inside WASM VMs. Usually running SNARKs inside WASM VMs will be several times slower than on a native CPU.&lt;/p&gt;
&lt;p&gt;Moreover, there are a couple of other limitations when using WASM:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;It doesn’t support multi-thread parallelism.&lt;/li&gt;
&lt;li&gt;Memory is limited. Usually you only have 1~4 G available (If you encounter &lt;code class=&quot;language-text&quot;&gt;[CompileError: WebAssembly.compile(): data segments count of 104626 exceeds internal limit of 100000&lt;/code&gt; when using &lt;a href=&quot;https://github.com/iden3/circom/tree/master/ports/wasm&quot;&gt;circom wasm port&lt;/a&gt; to compile a large circuit, it’s out of this reason). Otherwise you will have to compile your own WASM by yourself, like in &lt;a href=&quot;https://github.com/emscripten-core/emscripten/issues/8755#issuecomment-499682033&quot;&gt;here&lt;/a&gt;. But again, this brings inconvenience for other contributors/developers.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;When we develop large circuits using &lt;a href=&quot;https://github.com/iden3/circom/tree/master/ports/wasm&quot;&gt;circom wasm port&lt;/a&gt; 和 &lt;a href=&quot;https://github.com/iden3/snarkjs&quot;&gt;snarkjs&lt;/a&gt; we often encounter error messages like &lt;code class=&quot;language-text&quot;&gt;data segments count exceeds internal limit&lt;/code&gt; or &lt;code class=&quot;language-text&quot;&gt;insufficient memory&lt;/code&gt;, which bother our developments (the latter problem is not caused by WASM, but &lt;code class=&quot;language-text&quot;&gt;node.js&lt;/code&gt; default configurations though). It’s true that we can use &lt;a href=&quot;https://github.com/iden3/circom/tree/master/ports/c&quot;&gt;circom c port&lt;/a&gt; to solve this kind of problems. But there is no good wrapper existed, we would have to write a script to make use of &lt;a href=&quot;https://github.com/iden3/circom/tree/master/ports/c&quot;&gt;circom c port&lt;/a&gt; to compile the circuit and generate the witness. This may not be convenient for other developers who do not have this script.&lt;/p&gt;
&lt;p&gt;Due to the reasons mentioned above, we decide to develop and open-source &lt;a href=&quot;https://github.com/fluidex/snarkit&quot;&gt;https://github.com/fluidex/snarkit&lt;/a&gt;. It’s a wrapper for &lt;a href=&quot;https://github.com/iden3/circom/tree/master/ports/c&quot;&gt;circom c port&lt;/a&gt;, but it also adds better error detection. With &lt;a href=&quot;https://github.com/fluidex/snarkit&quot;&gt;https://github.com/fluidex/snarkit&lt;/a&gt;, people can use &lt;a href=&quot;https://github.com/iden3/circom&quot;&gt;circom&lt;/a&gt; to develop large circuits, the witness generation speed can also be boosted up. We believe this can make &lt;a href=&quot;https://github.com/iden3/circom&quot;&gt;circom&lt;/a&gt; circuit developments more friendly, and thus benefit zk-SNARKs ecosystem. &lt;/p&gt;
&lt;p&gt;We hope you all enjoy using it!&lt;/p&gt;</content:encoded></item><item><title><![CDATA[WASM 在用于 cryptogrphy 时的限制 -- 兼谈我们为什么想开发 snarkit]]></title><description><![CDATA[现在许多项目开始喜欢使用用 WebAssembly (WASM)，因为可以在浏览器中达到像运行 native CPU 指令一样快的效率：WASM 指令和 真正 CPU 指令之间不需要太多的 解释 (interpretation) 和转换。这对于支持多平台大有裨益。并且 WASM…]]></description><link>https://www.fluidex.io/zh/blog/the-motivation-of-snarkit/</link><guid isPermaLink="false">https://www.fluidex.io/zh/blog/the-motivation-of-snarkit/</guid><pubDate>Sat, 17 Apr 2021 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;现在许多项目开始喜欢使用用 WebAssembly (WASM)，因为可以在浏览器中达到像运行 native CPU 指令一样快的效率：WASM 指令和 真正 CPU 指令之间不需要太多的 解释 (interpretation) 和转换。这对于支持多平台大有裨益。并且 WASM 支持从 C/C++/Jave/Rust/GoLang… 等语言编译过去，方便现有开发人员迁移。&lt;/p&gt;
&lt;p&gt;但这只是理想的情况，事实上对于密码学相关代码来说这一切并没有那么美好：因为现代 CPU 有很多针对密码学的黑魔法/优化，如果在 WebAssembly 虚拟机里则无法利用这一点。一般来说在 WASM 里面跑 SNARK 会比在 native CPU 上慢好几倍。&lt;/p&gt;
&lt;p&gt;而且 WASM 还有各种各样的限制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不支持多线程并行。&lt;/li&gt;
&lt;li&gt;能使用的内存有限制。一般来说 最多提供 1-4 G 内存供使用。否则的话你就要编译你自己版本的 WASM，像&lt;a href=&quot;https://github.com/emscripten-core/emscripten/issues/8755#issuecomment-499682033&quot;&gt;这样&lt;/a&gt;。但这又会造成移植和使用上的不便。一般来说如果你在使用 &lt;a href=&quot;https://github.com/iden3/circom/tree/master/ports/wasm&quot;&gt;circom wasm port&lt;/a&gt; 编译 大型电路时遇到 &lt;code class=&quot;language-text&quot;&gt;[CompileError: WebAssembly.compile(): data segments count of 104626 exceeds internal limit of 100000&lt;/code&gt; 的话就是这个问题导致的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面的种种原因使我们下定决心开发并开源 &lt;a href=&quot;https://github.com/fluidex/snarkit&quot;&gt;https://github.com/fluidex/snarkit&lt;/a&gt; 。我们在使用 &lt;a href=&quot;https://github.com/iden3/circom/tree/master/ports/wasm&quot;&gt;circom wasm port&lt;/a&gt; 和 &lt;a href=&quot;https://github.com/iden3/snarkjs&quot;&gt;snarkjs&lt;/a&gt; 开发大型电路时总是遇到 data segments 或者 内存不够 等类似的报错，电路开发无法继续进行。使用 &lt;a href=&quot;https://github.com/iden3/circom/tree/master/ports/c&quot;&gt;circom c port&lt;/a&gt; 可以解决这样的问题。但 &lt;a href=&quot;https://github.com/iden3/circom/tree/master/ports/c&quot;&gt;circom c port&lt;/a&gt; 并没有得到很好的封装，每次都需要写脚本以调用来编译电路和生成 witness，这其实对于其他没有这些脚本的开发者并不方便。（有一些问题并不是 WASM 带来的，而是 node 默认参数带来的，但使用 snarkit 正好一并解决了这些问题。）&lt;a href=&quot;https://github.com/fluidex/snarkit&quot;&gt;https://github.com/fluidex/snarkit&lt;/a&gt; 对 &lt;a href=&quot;https://github.com/iden3/circom/tree/master/ports/c&quot;&gt;circom c port&lt;/a&gt; 进行了封装，使得开发者终于可以方便地使用 &lt;a href=&quot;https://github.com/iden3/circom&quot;&gt;circom 语言&lt;/a&gt; 开发大型电路，witness generation 也可以更加快。&lt;/p&gt;
&lt;p&gt;这就是我们开发 &lt;a href=&quot;https://github.com/fluidex/snarkit&quot;&gt;https://github.com/fluidex/snarkit&lt;/a&gt; 的初衷，欢迎大家使用。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[FluiDex 招聘]]></title><description><![CDATA[FluiDex Labs 致力于构建下一代专业的去中心化交易所。我们将在以太坊上使用 PLONK 零知识证明技术，开发高性能的订单簿数字资产现货交易所。完整的项目介绍见 这里。 我们的办公室在北京国贸附近，时间要求是 9:00 - 19:00。五天工作制。每年最低 1…]]></description><link>https://www.fluidex.io/zh/blog/joinus/</link><guid isPermaLink="false">https://www.fluidex.io/zh/blog/joinus/</guid><pubDate>Thu, 04 Mar 2021 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;FluiDex Labs 致力于构建下一代专业的去中心化交易所。我们将在以太坊上使用 PLONK 零知识证明技术，开发高性能的订单簿数字资产现货交易所。完整的项目介绍见 &lt;a href=&quot;/zh/blog/fluidex-a-zkrollup-layer2-dex/&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;我们的办公室在北京国贸附近，时间要求是 9:00 - 19:00。五天工作制。每年最低 13 薪，平均 14 薪。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;下面描述的所有报酬，都是到手！！&lt;/strong&gt; 此外，员工可以自由选择 期权/数字货币 等不同资产的比例。&lt;/p&gt;
&lt;h2&gt;为什么选择我们？&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;你能接触最前沿的区块链技术。我们使用前沿的零知识证明技术，来提升交易所的性能。我们拥抱开源，和技术社区一起探索技术的边界。你将会和极优秀的技术团队 (见 &lt;a href=&quot;/zh/blog/fluidex-a-zkrollup-layer2-dex/&quot;&gt;“FluiDex: 基于 ZK-Rollup 的专业去中心化交易所”&lt;/a&gt;) 中的 “创始人&amp;#x26;团队” 章节) 一起工作。&lt;/li&gt;
&lt;li&gt;你会工作得很舒服。团队推崇 长期价值/坦诚/正直/共赢 的文化。我们相信 用户/团队/投资人 共赢是可期的。&lt;/li&gt;
&lt;li&gt;你会作为早期员工分享项目成长的所有收益，无论是体验上的，还是经济上的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;全职部分&lt;/h2&gt;
&lt;p&gt;我们暂时只开放全职职位如下，近期可能会开放更多职位，欢迎关注。如果你对其他职位有兴趣（产品，设计，市场，运营等非技术职位），也欢迎和我们直接联系。&lt;/p&gt;
&lt;p&gt;对下面的所有职位，我们都希望你能有快速的学习能力，良好的技术英文读写能力。有出色的开源项目都是很大的加分项。&lt;/p&gt;
&lt;h3&gt;区块链开发工程师&lt;/h3&gt;
&lt;p&gt;工作内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用 Solidity 语言开发以太坊上的智能合约&lt;/li&gt;
&lt;li&gt;开发零知识证明电路系统，包括具体的交易所业务编码和 DSL 的持续改进&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们相关开源代码库：&lt;a href=&quot;https://github.com/fluidex/circuits&quot;&gt;FluiDex 零知识证明电路&lt;/a&gt; 和 &lt;a href=&quot;https://github.com/fluidex/plonkit&quot;&gt;一个 Plonk DSL 工具包&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;技能需求：熟悉区块链/智能合约等基础知识；对区块链相关技术有强烈兴趣；&lt;/p&gt;
&lt;p&gt;加分项：设计开发过任何 DSL 编译器；&lt;/p&gt;
&lt;p&gt;工资：35k-50k 到手。&lt;/p&gt;
&lt;h3&gt;高级 Rust 后端工程师&lt;/h3&gt;
&lt;p&gt;工作内容：设计开发我们的交易所后端，如撮合，行情，交易历史，数据统计等功能。目前我们的代码是开源的，可以去看一下我们的日常开发内容 &lt;a href=&quot;https://github.com/fluidex/dingir-exchange&quot;&gt;https://github.com/fluidex/dingir-exchange&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;技能需求：有常见后端开发技能，如数据库，消息队列，缓存，非阻塞 IO 等。熟悉 Rust 语言。&lt;/p&gt;
&lt;p&gt;工资：35k-50k 到手。&lt;/p&gt;
&lt;h3&gt;高级前端工程师&lt;/h3&gt;
&lt;p&gt;工作内容：设计开发我们的交易所网页，如下单，行情，交易历史，数据统计等功能。&lt;/p&gt;
&lt;p&gt;技能需求：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;熟练掌握前端基础知识，如 HTML JavaScript CSS 等。&lt;/li&gt;
&lt;li&gt;熟悉 React 生态。熟悉常见状态管理和 UI 组件。&lt;/li&gt;
&lt;li&gt;两年工作经验，或者相似工作量的项目经验。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;加分项：有以太坊相关开发经验；有一定的跨端能力。&lt;/p&gt;
&lt;p&gt;工资：30k-40k 到手。&lt;/p&gt;
&lt;!--

## 实习部分

工作内容：和全职部分相同。对于实习生，我们不需要有相关的经验，但是期待你能在几周内上手一个陌生领域。

能力要求：学习能力强（英文是日常技术读写语言，善用搜索引擎，拥有一定的技术广度，能够举一反三猜出陌生领域的要点），有计算机的基础知识（系统编程语言如 C/C++，Linux 常用命令行，脚本语言如 JS/Python），有基本的数学敏锐度。举个例子，这个 [commit](https://github.com/fluidex/plonkit/pull/2/commits/de055afb6a4f49f4d1ee1bd10cead7e3f204d84d) 修复了一个 solidity 语言实现的有限域 batch 除法的 bug。我们对实习生能力的预期是，在我们指导下，你能速成 solidity 基本语法，再速成一下有限域除法，然后通过 backtrace 看出 bug 原因并且修复。

报酬：100-150 每小时。一般来说大部分人实际拿到的，更接近于这个取值范围的左边而非右边。当然，如果实习生工作几周后，表现非常出色，报酬甚至不局限在这个范围内。

## 兼职部分

工作内容：和全职部分相同。主要针对有工作经验，在工作之余愿意赚点外快的人。

报酬：200 每小时。略高于全职员工，是因为对于兼职，我们一方面更难保证有持续不断的兼职工作需求，因此这部分溢价算是风险补偿，另一方面，我们期待兼职员工有更成熟的经验，需要更少的学习上手时间。

--&gt;
&lt;h2&gt;联系方式&lt;/h2&gt;
&lt;p&gt;Telegram 群：&lt;a href=&quot;https://t.me/fluid_dex&quot;&gt;https://t.me/fluid_dex&lt;/a&gt; (目前英文技术话题为主)&lt;/p&gt;
&lt;p&gt;Telegram: &lt;a href=&quot;https://t.me/lispczz&quot;&gt;https://t.me/lispczz&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;邮箱：z@fluidex.io&lt;/p&gt;
&lt;h2&gt;招聘哲学 &amp;#x26; 薪酬谈判 &amp;#x26; 激励 &amp;#x26; 工作强度&lt;/h2&gt;
&lt;p&gt;整个团队的合作氛围是“开诚布公，将心比心”。因此我们会提前写明期待的薪资范围（当然你如果确实够出色，我们也可以适度上调），而不是写“有竞争力的薪酬，上不封顶”这种无意义甚至不诚实的话。我们更喜欢用高一些的薪酬换员工更好的能力和稳定性，我们认为这是双赢。我们相信在公司人数少的时候，在薪酬上压三瓜俩枣得不偿失。&lt;/p&gt;
&lt;p&gt;我们认同 &lt;a href=&quot;https://open.leancloud.cn/salary-2018/&quot;&gt;这里&lt;/a&gt; 对于薪酬谈判的观点。不过客观上我们还没有 “什么样的人在市场该值多少钱” 的系统性知识，所以在未来一段时期内，我们还是会问候选人 “你上一份工作拿多少钱？”来积累数据点。&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;在招聘时，很多公司往往会根据候选人之前的薪酬以及他/她的期望值在可接受的范围内确定 offer。
这样的方式事实上惩罚了之前薪酬偏低的人和不善于薪酬谈判的人，而有利于之前薪酬偏高或者善于薪酬谈判的人，
造成了能力和贡献相似的人薪酬产生较大差别，也就导致了组织内部的不公平。&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们目前倾向于 bonus 按照季度尺度发放(除非碰到什么未预期的障碍)。这一方面能给员工更快的绩效反馈，帮助他们成长，另一方面，我们不想鸡贼地通过年终奖到年底甚至更迟才发放，来套牢白嫖员工几个月。&lt;/p&gt;
&lt;p&gt;我们不要求员工陪创始人加班。创始人愿意 996 是因为自己就是大股东，不是大股东不要求加班:)&lt;/p&gt;
&lt;!--
## FAQ

Q: 上面很多工资单位都是时薪，为什么是时薪，而不是日薪或者按照开发任务来结算？时薪怎么保证诚实？
A: 对于兼职开发者来说，不用以开发任务为单位结算，是因为我们想让感兴趣的求职者能很快地估算出自己的回报，而不需要花很多时间来深入到我们代码中评估。对于实习生来说，我们用时薪而不是常见的日薪，是想说明我们更能接受领灵活的工作方式，我们欢迎来公司干一天，也接受在宿舍里干几个小时。只要非全职开发者的实际工作耗时不是太不合理，我们都将按照他统计的时间来结算报酬。当然，最坏情况，公司有中止兼职/实习关系的权利。

Q: 我在海淀上学，感觉去朝阳太远了。
A: 你在路上的两个小时会被作为工作时间，算进报酬中。你也是可以远程工作的，当然我们还是更希望能来办公室。

Q: 为什么只开放这几个全职职位？其他职位没坑了吗？
A: 本着对公司和候选人双方负责的原则，我们每完全想清楚了一个职位的工作内容/能力要求/薪资范围，才会正式开放职位。其他职位我们还在最终确定工作内容和能力要求中，应该会很快出正式的职位描述。很欢迎提前和我们联系，期待听到你对职位的理解。

Q: 我联系你了，你们怎么不回复我？你们觉得我太菜吗，你们太没礼貌了。
A: 我绝对不会不回复的。没收到回复肯定是通信渠道出了问题，或者漏了消息，建议再试一次。

Q: 我觉得我有点菜，可以更低一些工资实习吗？
A: 我至少现在更倾向于维持小而精的团队。当然，如果过几周我们被现实打脸，搭建不起来小而精的团队，我们也许会考虑给更接近市场价的工资，找更普通的人。
--&gt;</content:encoded></item><item><title><![CDATA[FluiDex Recent Updates]]></title><description><![CDATA[About us: The FluiDex team is developing the first zk-rollup layer2 order-book DEX with permissionless listings on Ethereum. For a more…]]></description><link>https://www.fluidex.io/en/blog/2021-03-03-updates/</link><guid isPermaLink="false">https://www.fluidex.io/en/blog/2021-03-03-updates/</guid><pubDate>Thu, 04 Mar 2021 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;About us: The FluiDex team is developing the first zk-rollup layer2 order-book DEX with permissionless listings on Ethereum. For a more comprehensive introduction to the project, please see &lt;a href=&quot;/en/blog/fluidex-a-zkrollup-layer2-dex/&quot;&gt;our previous article&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In this post, We are happy to explain what we have achieved since the early 2021, at what time the project was launched.&lt;/p&gt;
&lt;h1&gt;Technical progress&lt;/h1&gt;
&lt;h3&gt;Plonkit&lt;/h3&gt;
&lt;p&gt;As the saying goes, good tools are prerequisite to the success of a job.&lt;/p&gt;
&lt;p&gt;Plonkit is a PLONK zero-knowledge proof toolkit developed by the FluiDex team. By using Plonkit, users can use an easier DSL (Circom) to implement their own zero-knowledge proof circuit code, without the need to learn the underlying cryptography library and how to write circuits in C or Rust (which is way more complicated).&lt;/p&gt;
&lt;p&gt;The core of Plonkit is developed based on the bellman_ce cryptography library. The current functions include local setup (for development use only, in production better to use MPC ceremony), circuit proving and verification, solidity verification contract generation, etc.&lt;/p&gt;
&lt;p&gt;Plonkit has received a lot of attention from developers since being open sourced, and it is now the project with the most stars on github by the team.&lt;/p&gt;
&lt;p&gt;We are implementing server mode so that plonkit can serve for continuously-running proving service. In the future, we will further implement the cluster proving server feature. In a longer term, we may add custom gates to further improve the performance of the system. In addition, we will continue to improve DSL specifically for PLONK and its variants.&lt;/p&gt;
&lt;p&gt;For more, please visit github: &lt;a href=&quot;https://github.com/fluidex/plonkit&quot;&gt;https://github.com/fluidex/plonkit&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Exchange&lt;/h3&gt;
&lt;p&gt;In the past a few months, the FluiDex team has finished the first version of the exchange matching engine backend and web frontend. The backend of the matching engine has been open sourced, using Rust language to implement in-memory order matching, which can achieve thousands of TPS. This will ensure the fluency and stability of our trading system in the foreseeable future. We are still improving this system continuously. (It hasn’t been tempered by real business, so it is only recommended to be used only for learning and communication at present rather than production).&lt;/p&gt;
&lt;p&gt;Currently, the back end of the exchange has been open sourced, and the front end has not yet been open sourced.
For more details, please visit github: &lt;a href=&quot;https://github.com/fluidex/dingir-exchange&quot;&gt;https://github.com/fluidex/dingir-exchange&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Zero-knowledge proof circuit and smart contract&lt;/h3&gt;
&lt;p&gt;We have delivered &lt;a href=&quot;https://github.com/fluidex/rescue-hash-js&quot;&gt;the first implementation of Javascript Rescue Hash&lt;/a&gt;, and also developed &lt;a href=&quot;https://github.com/fluidex/circuits/blob/master/src/lib/rescue.circom&quot;&gt;the first circom implementation of Rescue Hash circuit&lt;/a&gt;. Based on the Echarts sunburst chart, we have developed &lt;a href=&quot;https://github.com/fluidex/circuits/blob/master/tools/benchmark/profile_circuit.js&quot;&gt;a tool for profiling circuits visually&lt;/a&gt;. So users can analyze their own circuit code more conveniently, finding which parts of the circuits lead to the major computation overhead, so they can make further optimization accordingly.&lt;/p&gt;
&lt;p&gt;We have prototyped the most basic circuit code for deposit, withdrawal &amp;#x26; transfer &amp;#x26; trading. There are still many functions and performance details that need to be further improved, so we will not introduce it for the time being. Of course, all the code is at a very early stage, without any audit, it is not recommended for production use.&lt;/p&gt;
&lt;p&gt;All the above results have been open sourced in our code base. For more details, please visit github: &lt;a href=&quot;https://github.com/fluidex/circuits&quot;&gt;https://github.com/fluidex/circuits&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Awesome Plonk&lt;/h3&gt;
&lt;p&gt;This is a collection of high-quality materials about PLONK. It covers various learning materials such as papers, implementations, demos, forums, blog posts, videos, etc.&lt;/p&gt;
&lt;p&gt;For more details, please visit github: &lt;a href=&quot;https://github.com/fluidex/awesome-plonk&quot;&gt;https://github.com/fluidex/awesome-plonk&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;Community Status&lt;/h1&gt;
&lt;p&gt;Currently we only maintain the English technical community on Telegram. More than 100 developers who are interested in our project have joined in the past two months. In the future, we will continue to update our technological progress there.&lt;/p&gt;
&lt;h1&gt;Financing status&lt;/h1&gt;
&lt;p&gt;In the past few months, FluiDex has raised a total of more than US$500,000 from several private investors. We would like to thank these seniors in the industry for their financial and other support.&lt;/p&gt;
&lt;p&gt;The money is sufficient for our current development. We are not seeking further financing for the time being.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Update 2021.04.15:&lt;/strong&gt;
The project may soon launch a seed round of equity financing, and is looking for raising a total amount of around US$1 million at a valuation of US$7-10 million.&lt;/p&gt;
&lt;h1&gt;Technical contribution to other projects&lt;/h1&gt;
&lt;p&gt;We found a &lt;a href=&quot;https://github.com/matter-labs/solidity_plonk_verifier/pull/3&quot;&gt;bug when the number of inputs is greater than 1&lt;/a&gt; (&lt;a href=&quot;https://github.com/matter-labs/zksync/pull/284&quot;&gt;this code is also used in zksync&lt;/a&gt;), in the open sourced PLONK solidity verification contract code of Matters Lab, and submitted an upstream pull request. (The zksync online system does not trigger this code path, and the correctness and safety are not affected by this bug.)&lt;/p&gt;
&lt;p&gt;FluiDex is participating into the phase 2 trusted setup ceremony of the Hermez project, hoping to contribute to the wider Layer2 community through its own strength. (Explanation: What is the “phase 2 trusted setup ceremony”? The zk-rollup projects that use Groth16 protocol need to ensure the security of some cryptographic parameters by using multi-party computations. The “phase 2 trusted setup ceremony” is one of such multi-party computations. As long as at least one of the participants is honest, the entropy and hence randomness can be guaranteed. Provers then cannot forge a proof.)&lt;/p&gt;</content:encoded></item><item><title><![CDATA[FluiDex 近况更新]]></title><description><![CDATA[关于我们：FluiDex 团队正在开发 Ethereum 上第一个无许可上币的 zk-rollup layer2 订单簿 DEX。项目的完整介绍可以看这篇文章。 下面介绍从 2021 年初项目启动以来，团队在各方面的一些工作。 技术进展 Plonkit…]]></description><link>https://www.fluidex.io/zh/blog/2021-03-03-updates/</link><guid isPermaLink="false">https://www.fluidex.io/zh/blog/2021-03-03-updates/</guid><pubDate>Wed, 03 Mar 2021 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;关于我们：FluiDex 团队正在开发 Ethereum 上第一个无许可上币的 zk-rollup layer2 订单簿 DEX。项目的完整介绍可以看&lt;a href=&quot;/zh/blog/fluidex-a-zkrollup-layer2-dex/&quot;&gt;这篇文章&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;下面介绍从 2021 年初项目启动以来，团队在各方面的一些工作。&lt;/p&gt;
&lt;h1&gt;技术进展&lt;/h1&gt;
&lt;h3&gt;Plonkit&lt;/h3&gt;
&lt;p&gt;工欲善其事，必先利其器。&lt;/p&gt;
&lt;p&gt;Plonkit 是一个 FluiDex 团队开发的 PLONK 零知识证明工具包。通过使用 Plonkit，用户可以使用更容易上手的 DSL 来实现自己的零知识证明电路代码，而不需要学习 Rust 语言和底层密码学库的复杂细节。&lt;/p&gt;
&lt;p&gt;Plonkit 底层基于 bellman_ce 密码学库开发。目前的功能有，本地 setup（仅限开发使用，正式的 setup 最好还是进行 MPC ceremony），电路证明和本地验证，solidity 验证合约生成等。&lt;/p&gt;
&lt;p&gt;Plonkit 开源以来收到了很多开发者的关注，现在是团队在 github 上获得标星最多的项目。&lt;/p&gt;
&lt;p&gt;我们正在实现 server 模式，以便 plonkit 能够被作为长期运行的证明服务启动。未来我们会进一步实现集群证明服务功能。更长远地，我们可能会加入 custom gates 来进一步提升系统的性能上限，此外我们还会专门为 PLONK 及其变种持续改进 DSL。&lt;/p&gt;
&lt;p&gt;更多请访问 github: &lt;a href=&quot;https://github.com/fluidex/plonkit&quot;&gt;https://github.com/fluidex/plonkit&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;交易所&lt;/h3&gt;
&lt;p&gt;FluiDex 团队在过去几个月中，完成了交易所撮合引擎后端和网页端的第一个版本。后端撮合引擎部分已经开源，使用 Rust 语言实现了纯内存撮合，能够达到数千 TPS 的性能，这将保证我们交易系统在可见未来系统的流畅性和稳定性。项目已经在 github 开源。我们仍在持续完善中。（没有经过真实业务的锤炼，目前建议仅作学习交流使用）。&lt;/p&gt;
&lt;p&gt;目前交易所后端已经开源，前端暂未开源。
更多请访问 github: &lt;a href=&quot;https://github.com/fluidex/dingir-exchange&quot;&gt;https://github.com/fluidex/dingir-exchange&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;零知识证明电路和智能合约&lt;/h3&gt;
&lt;p&gt;我们完成了&lt;a href=&quot;https://github.com/fluidex/rescue-hash-js&quot;&gt;第一个 Javascript Rescue Hash 的实现&lt;/a&gt;，也开发了&lt;a href=&quot;https://github.com/fluidex/circuits/blob/master/src/lib/rescue.circom&quot;&gt;第一个 circom 语言版本的 Rescue Hash 电路代码&lt;/a&gt;。基于 Echarts 旭日图，我们开发了&lt;a href=&quot;https://github.com/fluidex/circuits/blob/master/tools/benchmark/profile_circuit.js&quot;&gt;可视化 profile 电路的工具&lt;/a&gt;，用户可以快速分析出自己电路代码中 cost 最大的是哪部分，便于进一步做细致的优化。&lt;/p&gt;
&lt;p&gt;我们完成了最基础的充提&amp;#x26;转账&amp;#x26;交易的电路代码，尚有较多功能和性能细节需要进一步完善，暂不展开介绍。当然，所有代码都在很早期，没有任何审计，不建议生产使用。&lt;/p&gt;
&lt;p&gt;上述所有成果都已经开源在我们的代码库中。更多请访问 github: &lt;a href=&quot;https://github.com/fluidex/circuits&quot;&gt;https://github.com/fluidex/circuits&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Awesome Plonk&lt;/h3&gt;
&lt;p&gt;这是我们收集的 PLONK 相关的优质资料的汇编。涵盖论文，实现，Demo，论坛，博客文章， 博客/视频等多方面的学习资料。&lt;/p&gt;
&lt;p&gt;更多请访问 github: &lt;a href=&quot;https://github.com/fluidex/awesome-plonk&quot;&gt;https://github.com/fluidex/awesome-plonk&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;社群状态&lt;/h1&gt;
&lt;p&gt;目前我们仅在 Telegram 上维护了英文技术社群。两个月来已经有 100 多位对我们感兴趣的开发者加入。未来我们会在那里持续更新我们的技术进展。&lt;/p&gt;
&lt;h1&gt;融资状态&lt;/h1&gt;
&lt;p&gt;过去几个月，FluiDex 从几位私人投资者中已经完成共计超过 50 万美元的融资。在此感谢这些业界前辈在财务和其他方面给予我们的支持。&lt;/p&gt;
&lt;p&gt;这些钱够我们目前的开发使用。我们暂时不寻求进一步的融资。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2021.04.15 更新:&lt;/strong&gt;
项目最近会寻求规模为 US$1M （估值 US$7-10 M）左右的融资。&lt;/p&gt;
&lt;h1&gt;对其他项目的技术贡献&lt;/h1&gt;
&lt;p&gt;我们发现了 matters lab 开源的 PLONK solidity 验证合约代码中 &lt;a href=&quot;https://github.com/matter-labs/solidity_plonk_verifier/pull/3&quot;&gt;当输入个数大于 1 时的 bug&lt;/a&gt; (&lt;a href=&quot;https://github.com/matter-labs/zksync/pull/284&quot;&gt;这个代码也用在 zksync 中&lt;/a&gt;)，并且提交了上游 pull request。（zksync 线上系统不触发这条代码路径，正确性和安全性不受这个 bug 影响。）&lt;/p&gt;
&lt;p&gt;FluiDex 正在参与 Hermez 项目的 phase 2 trusted setup ceremony，希望通过自己的力量，为更广泛的 Layer2 社区做出贡献。（解释：“phase 2 trusted setup ceremony”是什么？ 使用 Groth16 协议的 zk-rollup 的项目在上线前，一般会通过多方计算保证一些密码学参数的安全，“phase 2 trusted setup ceremony” 就是这样一个多方计算的过程。只要所有参与的用户有一个是不作恶的，整体的密码学系统就是安全的。）&lt;/p&gt;
&lt;h1&gt;其他&lt;/h1&gt;
&lt;p&gt;在国贸租了个小办公室～ 可以开心刷夜干活啦～
欢迎对我们项目有兴趣的朋友&lt;a href=&quot;/zh/blog/joinus/&quot;&gt;加入团队&lt;/a&gt;～&lt;/p&gt;</content:encoded></item><item><title><![CDATA[FluiDex: A ZK-Rollup layer2 DEX on Ethereum]]></title><description><![CDATA[What is FluiDex If you are familiar with cutting-edge blockchain technology, you can easily understand that FluiDex is a Layer…]]></description><link>https://www.fluidex.io/en/blog/fluidex-a-zkrollup-layer2-dex/</link><guid isPermaLink="false">https://www.fluidex.io/en/blog/fluidex-a-zkrollup-layer2-dex/</guid><pubDate>Mon, 30 Nov 2020 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;What is FluiDex&lt;/h1&gt;
&lt;p&gt;If you are familiar with cutting-edge blockchain technology, you can easily understand that FluiDex is a Layer 2 decentralized exchange on Ethereum. We use PLONK-based zkrollup technology to achieve high-performance transactions, while being able to reduce the cost of each transaction to less than 1% of normal L1 transaction. To our best knowledge, we are the first order-book exchange on Ethereum using PLONK-based validity proof.&lt;/p&gt;
&lt;p&gt;For those who are not familiar with these buzzy words, FluiDex is a crypto asset exchange similar to Coinbase or Binance, but non-custodial. The good thing is that your assets are absolutely “SAFU”. You don’t need to trust the team of the exchange to be ethical or law-abiding. You only need to trust cryptography and code. The bad thing is that it will be a bit less friendly to use, for example, transaction fees will be a bit higher in some cases.&lt;/p&gt;
&lt;h1&gt;Why build FluiDex&lt;/h1&gt;
&lt;p&gt;“Build a safe, professional and easy-to-use digital asset trading platform” is our long-term vision.&lt;/p&gt;
&lt;p&gt;I believe we all agree that to date Ethereum is probably the most decentralized and hence the most secure platform supporting DEX. In the following sections I will talk about what is “professional trading” in FluiDex’s understanding.&lt;/p&gt;
&lt;p&gt;We can roughly divide the traders in the market into two categories. One category is called “speculative retail investors”. They don’t care about miners’ fees and handling fees, and don’t care about the slippage loss of market orders. They just want to easily buy certain assets because in their mind the value this asset will “pump” several times. The other type, we call it “professional traders”, they care about miners’ fees and handling fees, they are skilled in using derivative hedging, they can arbitrage through different exchanges, and they are skilled in using limit/market/stoploss/FOK/IOC/AON order as a tool for different purposes, and may use a program to do automatic trading.&lt;/p&gt;
&lt;p&gt;On Ethereum today, exchanges based on algorithm-based automated market making, such as Uniswap, have gained high popularity. Except higher miner fees, such exchanges generally meet the needs of “speculative retail investors”. However, for this type of exchange, liquidity takers can only place market price orders. For liquidity maker, there will be profit (because of rebates) when the price is stable, but losses when the price fluctuates sharply. The above shortcomings are tolerable for “speculative retail investors”, but they are unacceptable for “professional traders”. For traders with a traditional financial background, if you tell them “there is no order book, you can’t place an order for rebates; you can only place a market order, and set a slippage threshold at most”, they will be shocked.&lt;/p&gt;
&lt;p&gt;We expect that more and more real assets will circulate in a decentralized manner in the future, and more and more types of traders will participate in trading. A simple swap exchanges will not be able to meet the needs of those advanced traders. The traditional order book exchange will be a much more favored solution.&lt;/p&gt;
&lt;p&gt;So why hasn’t the order book decentralized exchange exploded in the past few years? One of the reasons is ecology. In the early years, there were not many assets on Ethereum. The USDT stablecoin, which is well-known to traders, did not circulate on Ethereum two years ago. Another reason is technology development. Early-phase order-book exchanges make the cost of miners’ fees for each commission and transaction non-negligible compared to swap exchanges. Expensive order and transaction costs hurdle the explosion of order book exchanges. Today thanks to the springing up of zero-knowledge proof technology, we finally are able to provide a trading experience with zero-cost order placings and 0.0001$-cost deals.&lt;/p&gt;
&lt;p&gt;In summary, the development of a decentralized economy has brought up more and more traders and trading needs, and order book exchanges can better meet the needs of professional traders. In the past a few years, the development of cryptography technology has made it possible for high-performance, low-cost and secure order book transactions. In a word, it is exactly the right time to build FluiDex.&lt;/p&gt;
&lt;h1&gt;Similar products and projects&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Traditional centralized exchange. For quite a lot, maybe more than half, of the people, this type of exchange is good enough. However, for some people who have high requirements for fund security &amp;#x26; anonymity, the hidden danger of black swan always exists in centralized exchanges. Even for a big exchange like OKEx, it happened not long ago that the exchange was unable to withdraw the coin because the founder lost contact for more than a month.&lt;/li&gt;
&lt;li&gt;Algorithmic automated market making exchange. A typical example is Uniswap, which sets the price of buying and selling assets by always ensuring that the number of asset A * the number of asset B == the fixed value. In the previous paragraph, we explain that such exchanges are not enough for professional traders.&lt;/li&gt;
&lt;li&gt;Order book exchange based on optimistic rollup technology. This type of exchange has high performance and is easy to develop, but it has two major disadvantages. The first is that withdrawing from such exchanges requires confirmation time of weeks, which is completely unacceptable for most of the traders. Second, the security of optimistic rollup is not as good as “as safe as L1” zk rollup.&lt;/li&gt;
&lt;li&gt;Other products with similar technical decisions, such as diversifi and loopring. Yes, in a nutshell, FluiDex will compete head-to-head with them. That there are already one or two players in a potential big market, is not a reason why new players should not enter. It is not true that since OKEx is running well, Binance should not start a business. In addition, FluiDex and these projects will have some different decisions both in technology and product. For example, from a technical perspective, we will use PLONK as the protocol of zero-knowledge proof, which will bring faster product iteration, from a product perspective, we are likely to implement permissionless token listing.&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;About Decentralized Governance &amp;#x26; Token&lt;/h1&gt;
&lt;p&gt;I believe that our exchange is a traditional “centralized” exchange, with a only difference that we’re non-custodial. There are many interpretations of “decentralization”, the decentralization of assets, the decentralization of control (“governance”), and even the decentralization of teams. Based on our vision, the decentralization of assets (ie, the self-custody of assets) is the must-have. But, at least today, we believe that decentralization of governance is neither necessary nor sufficient for building a great product. Any product team should investigate users and markets, but no team should decide the future of product only base on users’ votes. Customers and shareholders are two kinds of people. You should not force or expect customers to become shareholders. For the FluiDex team, “the customer is always right“, but there will be no so-called “decentralized” governance in the future. The decision-making power of the future of the product will always be in the hands of the management team, and users will vote for our success or failure with their feet.&lt;/p&gt;
&lt;p&gt;Based on our understanding of governance philosophy above, FluiDex will not issue “governance tokens” in the foreseeable future, but we are not against to issue tokens with dividend rights for fundraising. For example, it is entirely possible for us to issue a token and buy back this token with 10% of the monthly gross profit for the next 3 years.&lt;/p&gt;
&lt;h1&gt;Project status &amp;#x26; schedule &amp;#x26; financing&lt;/h1&gt;
&lt;p&gt;FluiDex project was launched at the end of 2020. It is expected that the MVP/demo will be completed in Q2 of 2021, and the mainnet launch will probably start in Q4 of 2021.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Update 2021.04.15:&lt;/strong&gt;
The project may soon launch a seed round of equity financing, and is looking for raising a total amount of around US$1 million at a valuation of US$7-10 million.&lt;/p&gt;
&lt;h1&gt;Contact&lt;/h1&gt;
&lt;p&gt;Telegram: &lt;a href=&quot;https://t.me/fluid_dex&quot;&gt;https://t.me/fluid_dex&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Medium: &lt;a href=&quot;https://fluid-dex.medium.com&quot;&gt;https://fluid-dex.medium.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Twitter: &lt;a href=&quot;https://twitter.com/fluid_dex&quot;&gt;https://twitter.com/fluid_dex&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Email: z@fluidex.io&lt;/p&gt;</content:encoded></item><item><title><![CDATA[FluiDex: 基于 ZK-Rollup 的专业去中心化交易所]]></title><description><![CDATA[FluiDex 是什么 对于熟悉前沿技术的人来说，FluiDex 是一个在以太坊上的 Layer2 去中心化交易所。我们将使用基于 PLONK 的 zkrollup 技术来实现高性能交易，同时能够将每笔交易的成本压缩到传统去中心化交易所的 1/10…]]></description><link>https://www.fluidex.io/zh/blog/fluidex-a-zkrollup-layer2-dex/</link><guid isPermaLink="false">https://www.fluidex.io/zh/blog/fluidex-a-zkrollup-layer2-dex/</guid><pubDate>Sat, 28 Nov 2020 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;FluiDex 是什么&lt;/h1&gt;
&lt;p&gt;对于熟悉前沿技术的人来说，FluiDex 是一个在以太坊上的 Layer2 去中心化交易所。我们将使用基于 PLONK 的 zkrollup 技术来实现高性能交易，同时能够将每笔交易的成本压缩到传统去中心化交易所的 1/100 以下。我们将会是以太坊上第一个使用 PLONK 的基于 validity proof 的订单簿交易所。&lt;/p&gt;
&lt;p&gt;对于普通大众来说，FluiDex 是一个类似 Coinbase 或者 火币 的加密资产交易所，优点是你的资产绝对安全，你不需要信任交易所创始人有道德或守法律，你只需要信任密码学和代码。缺点是会更不好用一些，例如交易费用在一些情况下会更高。&lt;/p&gt;
&lt;h1&gt;为什么要做 FluiDex&lt;/h1&gt;
&lt;p&gt;“做一个安全专业好用的数字资产交易平台” 是我们长期的愿景。&lt;/p&gt;
&lt;p&gt;在今天存在的技术产品范围内看，“安全”就意味着以太坊，这个几乎不用解释。下面我会讲讲 FluiDex 怎么理解“专业的交易”。&lt;/p&gt;
&lt;p&gt;我们把市场中的交易者粗略分为两类，一类我们叫“投机散户”，特点是不在乎矿工费和手续费，不在乎市价单的滑点损失，只是希望能够方便地买入某种资产，因为他们赌这种资产会涨几倍，另一类，我们称“专业交易员”，他们在乎矿工费和手续费，熟练使用衍生品套保，能够通过不同交易所价差套利，熟练使用限价/止损/市价/FOK/IOC/AON 单作为自己不同目的的工具，可能会使用程序做自动交易。&lt;/p&gt;
&lt;p&gt;在今天的以太坊上，Uniswap 这类基于算法自动化做市的交易所获得了很高的热度。这类交易所除了矿工费较高外，大体上满足了“投机散户”的需求。但是，这类交易所，对 liquidity taker 来说，只能挂市价单，对 liquidity maker 来说，价格稳定时有返佣盈利，价格剧烈波动时有损失。以上这些缺点，对于 “投机散户” 是可以容忍的，但是对于“专业交易员”是无法想象的。对于每一个传统金融出身的交易者，你如果告诉他们“这里没有订单簿，你也不能挂单吃返佣；你们只能下市价单，最多设置一下滑点”，他们都会惊掉下巴。&lt;/p&gt;
&lt;p&gt;我们预期未来会有越来越多的真实资产会以去中心化的方式流通，也会有越来越多类型的交易者参与交易。过于简单的 swap 类交易所，将无法满足相当多的高级交易者的需求。传统的订单簿交易所，将是一个好用得多的解决方案。&lt;/p&gt;
&lt;p&gt;那过去几年为什么订单簿去中心化交易所没有爆发呢？一方面是生态环境，早几年以太坊上承载的资产还不算特别多，要知道炒币者皆知的 USDT 稳定币，两年前都没有在以太坊上流通。另一方面是技术，订单簿交易所的早期简单实现，会使得每笔委托和交易的矿工费成本和 swap 类交易所相当，昂贵的挂单和交易成本束缚了订单簿交易所的爆发，而今天，得益于过去两年零知识证明技术雨后春笋般地爆发，我们终于能提供 0 成本挂单，0.0001 成本成交的交易体验。&lt;/p&gt;
&lt;p&gt;综上，去中心化经济的发展，带来越来越多的交易者和交易需求，订单簿交易所才能较好地满足专业交易者的需求。而过去几年密码学技术的进展，使得高性能低成本安全的订单簿交易所成为可能。因此，现在做 FluiDex，恰逢其时。&lt;/p&gt;
&lt;h1&gt;怎么看待类似的产品和项目&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;传统中心化交易所。对于相当多，甚至是一大半的人来说，这类交易所已经足够好用了。不过对于一些对资金安全 &amp;#x26; 匿名性要求较高的人来说，中心化交易所始终存在黑天鹅的隐患，是不够的。即使是 OKEx 这样的大交易所，不久前也发生了因为创始人失联一个多月没法提币的事情。&lt;/li&gt;
&lt;li&gt;算法自动化做市交易所。典型的是 Uniswap，通过始终保证资金池中 资产 A 的数量 * 资产 B 的数量 == 定值，来确认买卖资产的价格。上一段中，我们解释了我们为什么认为这类交易所对于专业交易者是不够用的。&lt;/li&gt;
&lt;li&gt;基于 optimistic rollup 技术的订单簿交易所。这类交易所性能较高，而且开发容易，但是有两个重大缺点。第一是，资金从这种交易所提出，需要周尺度的确认时间，这对很多资金是完全没法接受的。第二，optimistic rollup 的安全性是有假设有牺牲的，和 zk rollup 的“绝对安全“不同。&lt;/li&gt;
&lt;li&gt;其他类似技术路线的产品，如 diversifi 和 loopring。是的，概括地说，FluiDex 将和他们硬碰硬头对头地竞争。因为我们觉得，一个潜在的大赛道已经有了一两个玩家，不是后面玩家不该进入的理由。不能说 OKEx 运行很好，Binance 就不该创业了。此外，FluiDex 和这些项目还会有一些具体的技术和产品路线区分，例如技术角度，我们会使用 PLONK 作为零知识证明的底层，这会带来更快的产品迭代效率，产品角度，我们很可能会实现无许可上币。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;控制权 &amp;#x26; 去中心化治理 &amp;#x26; 发币&lt;/h1&gt;
&lt;p&gt;我内心更倾向认为，我们的交易所就是一个传统的“中心化”交易所，唯一的不同是资产的自托管。“去中心化”有很多种解读，资产的去中心化，控制权（“治理”）的去中心化，甚至团队的去中心化。基于我们的愿景来看，资产的去中心化（即资产的自托管），对我们是必需的。但是，至少今天，我们认为控制权的去中心化对于构建一个伟大产品而言，既非必要，也不充分。任何团队做产品都会调研，但是不会有团队仅仅通过用户的投票来决定未来。从古至今，客户和股东就是两种人，你不应该强迫或者期待客户成为股东。对于 FluiDex 团队来说，客户至上，但可见未来不会有所谓“去中心化”治理，产品的未来的决策权始终会在团队管理层手中，期待用户用脚来给我们的成败投票。&lt;/p&gt;
&lt;p&gt;基于以上我们对控制权的认知，FluiDex 在可见未来不会发行有投票权的 “治理代币”，但是我们不反对发行有分红权的代币来做募资。比如，我们完全有可能发行一种代币，保证用今后 3 年每月毛利的 10%来回购这种代币。&lt;/p&gt;
&lt;h1&gt;项目状态 &amp;#x26; 时间表 &amp;#x26; 融资&lt;/h1&gt;
&lt;p&gt;FluiDex 项目在 2020 年底启动，预期在 2021 年 Q2 完成最小 Demo 开发，在 2021 年 Q4 能够部署主网。&lt;/p&gt;
&lt;p&gt;Update 2021.04.15:
项目可能很快会启动种子轮股权融资，期待按照 700-1000 万美元的估值获得总额 100 万美元左右融资。&lt;/p&gt;
&lt;h1&gt;创始人 &amp;#x26; 团队&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;#team&quot;&gt;创始团队&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;CEO: 张卓。毕业于清华大学计算机系，曾任人工智能独角兽依图科技的语音识别负责人，曾负责 IOST 公链的研发。&lt;/p&gt;
&lt;p&gt;CTO: 林浩宇。VRF-mining, RandChain, fair-atomic-swap 共同发明人。ZenGo 研究员。曾负责比原链研发。&lt;/p&gt;
&lt;h1&gt;招聘&lt;/h1&gt;
&lt;p&gt;我们正在招聘全职/兼职/实习工程师。完整的招聘信息在 &lt;a href=&quot;https://github.com/fluidex/we_are_hiring&quot;&gt;we are hiring&lt;/a&gt;。我们的开源项目在 &lt;a href=&quot;https://github.com/fluidex&quot;&gt;FluiDex&lt;/a&gt; 下面，目前有 &lt;a href=&quot;https://github.com/fluidex/plonkit&quot;&gt;零知识证明工具包 Plonkit&lt;/a&gt;，&lt;a href=&quot;https://github.com/fluidex/dingir-exchange&quot;&gt;交易所撮合引擎 dingir-exchange&lt;/a&gt;，&lt;a href=&quot;https://github.com/fluidex/circuits&quot;&gt;零知识证明电路 DSL 代码&lt;/a&gt;。我们团队 Base 在北京，希望新成员尽量在北京，但也可以接受 remote 工作。&lt;/p&gt;
&lt;h1&gt;联系方式&lt;/h1&gt;
&lt;p&gt;Telegram 技术群: &lt;a href=&quot;https://t.me/fluid_dex&quot;&gt;https://t.me/fluid_dex&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Medium: &lt;a href=&quot;https://fluid-dex.medium.com&quot;&gt;https://fluid-dex.medium.com&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Twitter: &lt;a href=&quot;https://twitter.com/fluid_dex&quot;&gt;https://twitter.com/fluid_dex&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;公众号: 搜索 “FluiDex”.&lt;/p&gt;
&lt;p&gt;邮箱：z@fluidex.io&lt;/p&gt;</content:encoded></item></channel></rss>