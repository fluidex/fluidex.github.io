{"componentChunkName":"component---src-templates-post-template-js","path":"/en/blog/introducing-plonkit/","result":{"data":{"markdownRemark":{"excerpt":"TL;DR Plonkit is a zkSNARK toolkit to work with Circom, a developer-friendly ZKP circuit language, in PLONK proof system. It allows generating proof, verifying…","html":"<h2>TL;DR</h2>\n<p>Plonkit is a zkSNARK toolkit to work with <a href=\"https://github.com/iden3/circom\">Circom</a>, a developer-friendly ZKP circuit language, in <a href=\"https://eprint.iacr.org/2019/953.pdf\">PLONK proof system</a>. It allows generating proof, verifying and exporting verifier smart contract.</p>\n<h2>The motivation of plonkit</h2>\n<p>To date, <a href=\"https://eprint.iacr.org/2019/953.pdf\">PLONK</a> is one of the most performant zk-SNARKS proof systems in terms of proving time and proof size. <a href=\"https://vitalik.ca/general/2019/09/22/plonk.html\">As explained by Vitalik Buterin</a>, by being benefited from “universal and updateable” setup, PLONK is more secure when compared to <a href=\"https://eprint.iacr.org/2016/260.pdf\">Groth16</a>, without introducing much performance loss.</p>\n<p>However, it is inefficient to write circuits in pure C++/Rust/… , which requires writing a lot of constraints by hand. By using developer-friendly Circom DSL, people can then write circuits more efficiently and more conveniently. Aiming at bringing PLONK to Circom ecosystem, plonkit is designed. <sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup></p>\n<h2>Functionalities</h2>\n<p>The functionalities of plonkit include:</p>\n<ul>\n<li>Local Structured-Reference-String (SRS) setup</li>\n<li>Verification Key Generation (corresponding to a given circuit)</li>\n<li>Proof Generation</li>\n<li>Proof Verfication</li>\n<li>Verifier Smart Contract Generation</li>\n<li>Proof Aggregation</li>\n</ul>\n<h3>Local SRS setup</h3>\n<p>To export a verification key and to generate a proof (both explained later), we need a Structured-Reference-String. In <a href=\"https://github.com/fluidex/plonkit/blob/master/test/test_poseidon_plonk.sh\">test_poseidon_plonk.sh</a>, we provide a download link <sup id=\"fnref-2\"><a href=\"#fn-2\" class=\"footnote-ref\">2</a></sup> for a SRS file previously set up. According to <a href=\"https://github.com/matter-labs/bellman/blob/f551a55d83d2ea604b2dbfe096fd9dcfdaedb189/src/kate_commitment/mod.rs#L1090\">matter-labs</a>, this SRS file is parsed from <a href=\"https://medium.com/aztec-protocol/aztec-announcing-our-ignition-ceremony-757850264cfe\">AZTEC’s ignition setup</a>.</p>\n<p>For the convenience for testing, we add the support for genenrating SRS locally.</p>\n<h3>Verification Key Generation</h3>\n<p>Users can export a verification key for a circuit. The verification key is needed for future proof verification.</p>\n<h3>Proof Generation</h3>\n<p>A prover can generate a proof proving he knows a witness satisfying the circuit.</p>\n<h3>Proof Verfication</h3>\n<p>Proof verfication is to verified a proof using a verification key.</p>\n<h3>Verifier Smart Contract Generation</h3>\n<p>Users can generate a verifier smart contract based on a verification key, then a proof can be verified on EVM using this smart contract.</p>\n<h3>Proof Aggregation</h3>\n<p>Plonkit wraps up <a href=\"https://github.com/matter-labs/recursive_aggregation_circuit\">recursive_aggregation_circuit</a> to achieve proof aggregation. Proof aggregation is based on “Recursive Proof Composition” described in <a href=\"https://eprint.iacr.org/2019/1021.pdf\">Halo</a> paper.</p>\n<p>Some points worth noting (in the following explanations “we” stands for both “plonkit” and <a href=\"https://github.com/matter-labs/recursive_aggregation_circuit\">recursive_aggregation_circuit</a>):</p>\n<ul>\n<li>Unlike Halo, we don’t use cyclic curves but simulate base field operations <sup id=\"fnref-3\"><a href=\"#fn-3\" class=\"footnote-ref\">3</a></sup>, because on Ethereum we only have one curve (BN_254).</li>\n<li>We aggregate multiple proof into an aggregated proof in one step, instead of iterating and aggregating one by one.</li>\n<li>We don’t check the pairing in the circuit. Instead, we aggregate the pairing points and check the pairing in smart contract.</li>\n</ul>\n<h2>Workflow / Usecase</h2>\n<p>The diagram below demonstrates a typical workflow of using plonkit:</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/b83f1e0a8f618a8a753621d467492acf/7dd84/plonkit.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 39.87341772151899%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAD2EAAA9hAHVrK90AAACJUlEQVQoz01Sy4vSURQ+YxOIJOM0/YaKZtmQEtYsmiCFNmMRjS36AyqCGRI3Lgx0MTtBEREZxRciKKKiIj5ARcXH+AbxzagguFJCyUVtJIhf5wpFFy6H853Xd757IR6PM1KpFCMYDG7RNA25XA7W6zWYzWbIZrOMYrHIGA6H24vFArrdrq3dbtO9Xm8tkUgeVyqV15jzCgCYFEXtADnYENLpNEQiEUgkEhvs8vISHA4HYDOoVqtgsVhguVxCrVZ7gXkXmH+uVCo5Ho+H43a7d7HkJofDoQghCIVCR7FY7LnX6933+/1AQJ1OB1ar9RYOeJbJZI5dLteuQqGAcDi8iZMrFothPB5DIBAAjBMeTJPJBHB9ff0TA3Sz2bxA8IZUKmWjZTidzvfz+ZzGVWlcS0KaFAqF2yqV6kitVj8kvlAoBC6XC1qt9o5cLn9qMBjuEZ1OSqXSKep4QKgzmcxDtKxGo8HO5/NvUKe3yPQ+Yux6ve6czWb0dDr9hqu+7Pf7n1ksFoXaxlerFY3xHzAajb5jAl0ulxVYtC0QCPZJY9TwHTL/NZlMfuOwM8Iah/N9Pt8n1PHUaDTuIE6RGpTsGLEPyWTyBFqt1sfBYPAFhX7yVx9ybTbbQafTOUMW55h8SDCNRvMvLpPJADcDHo8HdrudaLiF7wGARURHsjr83xAZkG8COAyi0ShcXV1tfgCfz99DQ+n1+kcoy1eRSHQX/b0HeEjdH+dbR5RZJ2+cAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"plonkit\"\n        title=\"plonkit\"\n        src=\"/static/b83f1e0a8f618a8a753621d467492acf/f058b/plonkit.png\"\n        srcset=\"/static/b83f1e0a8f618a8a753621d467492acf/c26ae/plonkit.png 158w,\n/static/b83f1e0a8f618a8a753621d467492acf/6bdcf/plonkit.png 315w,\n/static/b83f1e0a8f618a8a753621d467492acf/f058b/plonkit.png 630w,\n/static/b83f1e0a8f618a8a753621d467492acf/40601/plonkit.png 945w,\n/static/b83f1e0a8f618a8a753621d467492acf/78612/plonkit.png 1260w,\n/static/b83f1e0a8f618a8a753621d467492acf/7dd84/plonkit.png 3732w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>The <a href=\"https://github.com/fluidex/plonkit/blob/master/test/test_poseidon_plonk.sh\">test_poseidon_plonk.sh</a> script is also a comprehensive example of the whole workflow.</p>\n<h2>Acknowledgements</h2>\n<ul>\n<li>\n<p>Plonkit builds on top of the awesome libraries written by matter-labs:</p>\n<ul>\n<li><a href=\"https://github.com/matter-labs/bellman\">bellman_ce</a></li>\n<li><a href=\"https://github.com/matter-labs/solidity_plonk_verifier\">solidity_plonk_verifier</a></li>\n<li><a href=\"https://github.com/matter-labs/recursive_aggregation_circuit\">recursive_aggregation_circuit</a></li>\n</ul>\n</li>\n<li>Plonkit also borrows some “R1CSFile reader” codes from <a href=\"https://github.com/poma/zkutil\">zkUtil</a>.</li>\n<li>Furthermore, thanks to the great work and effort from the team behind <a href=\"https://github.com/iden3/circom\">Circom</a>, developers can benefit from a friendly ZKP development language.</li>\n</ul>\n<p>Thanks the great work of these teams/individuals!</p>\n<p>Try out plonkit <a href=\"https://github.com/fluidex/plonkit\">here</a> and have fun!</p>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\">\n<p>By the time of starting plonkit project, Circom/snarkJS didn’t support PLONK but <a href=\"https://blog.iden3.io/circom-snarkjs-plonk.html\">it does now</a>. Still, proving in plonkit is more efficient than in snarkJS (plonkit uses Rust and snarkJS uses JS, and their PLONK implementations are different), whereas snarkJS can be run in browsers but plonkit cannot.</p>\n<a href=\"#fnref-1\" class=\"footnote-backref\">↩</a>\n</li>\n<li id=\"fn-2\">\n<p>Taken from <a href=\"https://github.com/matter-labs/zksync/blob/master/infrastructure/zk/src/run/run.ts#L77\">https://github.com/matter-labs/zksync/blob/master/infrastructure/zk/src/run/run.ts#L77</a></p>\n<a href=\"#fnref-2\" class=\"footnote-backref\">↩</a>\n</li>\n<li id=\"fn-3\">\n<p>We simulate base field elements as “limb”s.</p>\n<a href=\"#fnref-3\" class=\"footnote-backref\">↩</a>\n</li>\n</ol>\n</div>","frontmatter":{"title":"Introducing plonkit","tags":["technical"],"date":"2021-10-19T20:00:00.000Z","description":"When PLONK and Circom meet each other."}},"prev":null,"next":{"frontmatter":{"title":"A Dive into FluiDex's Architecture"},"fields":{"slug":"/en/blog/fluidex-architecture/"}}},"pageContext":{"slug":"/en/blog/introducing-plonkit/","prevSlug":null,"nextSlug":"/en/blog/fluidex-architecture/","langKey":"en"}},"staticQueryHashes":["2555585279","2841359383","3159585216"]}