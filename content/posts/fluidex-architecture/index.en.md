---
title: "A Dive into Fluidex's Architecture"
date: 2021-07-14 20:00:00
tags: [technical]
description: "Building the first fully open-source zk-rollup orderbook dex in the world."
---

> The cryptography underlying zero knowledge proofs has undergone a Moore’s Law-like trajectory over the last few years, and it shows no sign of slowing down.
> 
> -- [Dragonfly Research](https://medium.com/dragonfly-research/im-worried-nobody-will-care-about-rollups-554bc743d4f1)

ZK-Rollup, with its terrific security and decentralization properties, is believed as the most important Layer 2 scaling solution in the long term. However, the nice features of ZK-Rollup come with a cost of technical difficulties, in terms of both cryptography and engineering. No wonder why there are only a few relevant devtools or user-end products out there. As one of a few teams that are developing a ZK-Rollup system from scratch instead of forking, Fluidex decides to share some of our experience and outcomes with the industry, to help explode the ZK-Rollup ecosystem.

Before moving on, we recommend our readers to check out the article ["ZK-Rollup development experience sharing, Part I"](/en/blog/zkrollup-intro1/), in which we talk about how to develop and optimize ZK-Rollup. As the second part of this “development experience-sharing” series, this article focuses on our recently open-sourced back-end architecture, aiming at guiding more developers into the ZK-Rollup ecosystem.

## Overall Architecture

The diagram below shows the overall architecture of Fluidex's back-end. In a nutshell, users send order requests to the matching engine, and the matching engine sends all the finished orders to the message queue. The rollup module then updates the states (users' orders, users' balances...) on the Merkle tree and packs the messages into L2 blocks. After L2 blocks being proved by prover-cluster, they will be published onto chain.

<p align="center">
  <img src="Fluidex Architecture.svg" width="600" >
</p>

We will now first introduce the functionalities and responsibilities of each submodule, and then summarize the design principles of a ZK-Rollup system.

## Submodules

### Gateway

Gateway is to accept order requests from front-end or quant trading bots, and to route them to different micro-services. Gateway will also update the internal market k-line and orderbook, push them to the ticker subscribers[^1] in a desired format. We choose Envoy for our gateway because of its performance and flexibility in configuration. Besides, it is also important that Envoy has excellent support for GRPC, since Fluidex uses GRPC extensively in unary RPC and bidirectional streaming RPC.

### Matching Engine

[dingir exchange](https://github.com/Fluidex/dingir-exchange) is a high-performance exchange matching engine. It matches user orders in RAM. We use BTreeMap[^2] for our orderbook, because it requires both Key-Value query (for order details) and in-order traversal (for order matching), this means that it needs an ordered associative array like AVL Tree / Skip List. Moreover, BTreeMap can benefit from modern CPUs' cache architecture.

The persistence of the global state is achieved by periodical dumps and operation logs. By periodical process [forks](https://en.wikipedia.org/wiki/Fork_(system_call)), which has lower latency than "stop-world" and than "deep-copy", the new child process persists the global state. In addition, all user requests are persisted into the database in batches (otherwise leading to heavy database pressure) as operation logs. The combination of the two persistence mechanisms ensures that if the system suddenly goes down, the system state can be quickly recovered.

High, low, open, close and volume are queried from TimescaleDB, a time series database, to generate K-line.

### Rollup State Manager

In a ZK-Rollup system, the smart contract only needs to store the Merkle root of the global state instead of the entire Merkle tree of all the states. The maintenance of the Merkle tree is done by the off-chain rollup state manager. Rollup state manager receives finished orders and other operations (e.g., withdrawal, transfer...) from the message queue and update the Merkle tree. Operations are packed into L2 Blocks.

Rollup will periodically dump checkpoints (with message queue offsets). When the system restarts, it will load the state of Merkle tree from the last checkpoint, seek the corresponding offset in the message queue, and reprocess the messages in the message queue to recover the latest state.

### Proving Cluster

After a L2 block is generated by the rollup state manager, a cryptographic proof is needed so that this block can be verified as correct on chain. This requires a proof cluster to provide heavy computing power. In addition, since the transaction volume of a DEX may vary considerably in different periods of time, this proof cluster needs to be highly scalable and elastic.

To meet these requirements, we adopt the Master-Worker architecture, which is comprised of a stateful master node that manages a list of proving tasks, and many stateless worker nodes that retrieve tasks from the master and submit proofs to the master after proving. Similar to POW mining, since the computation for ZK-Rollup verification is much lightweight than that of proving, in the long run, we will able to switch to a more "trustless" architecture. In ideal cases, external nodes that do not require permissions (Miners) can join and exit the proof cluster freely, while the verification nodes can quickly confirm that the miners have completed the calculations honestly and did not commit evil.

At present, prover cluster provides two different deployment styles - via Docker Compose and via K8S - to support local development/debugging and production environment deployment.

## Design Principles of the Fluidex Back-end

### CQRS and Global Message Bus

The status update of the Rollup system requires strong consistency and extreme accuracy – not even the slightest error. All status update operations are preferably traceable and replayable. To provide such reliable status update, we adopted the CQRS design pattern. All write operations to the global state are synchronized by Message Queue. Specifically, we use Kafka as the global message bus. The Rollup system uses the message queue as the ground truth, obtains each notification for status update from the message queue, and executes it on the global Merkle Tree.

### Memory-centric Data Organization

Ordinary Internet services use databases as the ground truth of data. They usually acquire the scalability and scalability of the overall system through data fragmentation and statelessness of services.

To the contrary, our ZK-Rollup system includes many services that have to maintain a large number of complex data structures in memory (such as the Rollup and Matching Engine services that maintains the Merkle Tree and Orderbook respectively). This requires an architectural design centered on memory data. As a result, many of our design principles may be inconsistent with the 12 Factor revered by some Internet business but are closer in nature to the game server developers.

### Dedicated Technology Stack

Thanks to Rust's type safety and ownership checks, as well as the performance comparable with C++, Rust has become the first choice for many cryptographic libraries, and the ecology has become increasingly prosperous. Therefore, it is not surprising that our Rollup State Manager and Prover Cluster are developed in Rust language. Besides, since a unified technology stack can greatly reduce frictions both in terms of teamwork and technology management, other service modules in the system are also implemented in Rust language at present.

## Source Codes

Fluidex-backend has been open-sourced on Github and please refer to https://github.com/Fluidex/fluidex-backend. (Currently only with instructions on how to run it as a local cluster.) 

[^1]: "grpc->websocket" not implemented yet.
[^2]: https://doc.rust-lang.org/stable/std/collections/struct.BTreeMap.html
